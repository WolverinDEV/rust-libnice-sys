#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::all)]
#![allow(dead_code)]

use crate::fixup::*;

/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NiceAgent {
    _unused: [u8; 0],
}
#[doc = " NiceAgent:"]
#[doc = ""]
#[doc = " The #NiceAgent is the main GObject of the libnice library and represents"]
#[doc = " the ICE agent."]
pub type NiceAgent = _NiceAgent;
#[doc = " NiceAddress:"]
#[doc = ""]
#[doc = " The #NiceAddress structure that represents an IPv4 or IPv6 address."]
#[repr(C)]
pub struct _NiceAddress {
    pub s: _NiceAddress__bindgen_ty_1,
}
#[repr(C)]
pub struct _NiceAddress__bindgen_ty_1 {
    pub addr: __BindgenUnionField<sockaddr>,
    pub ip4: __BindgenUnionField<sockaddr_in>,
    pub ip6: __BindgenUnionField<sockaddr_in6>,
    pub bindgen_union_field: [u32; 7usize],
}
#[test]
fn bindgen_test_layout__NiceAddress__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NiceAddress__bindgen_ty_1>(),
        28usize,
        concat!("Size of: ", stringify!(_NiceAddress__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NiceAddress__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NiceAddress__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceAddress__bindgen_ty_1>())).addr as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceAddress__bindgen_ty_1),
        "::",
        stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceAddress__bindgen_ty_1>())).ip4 as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceAddress__bindgen_ty_1),
        "::",
        stringify!(ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceAddress__bindgen_ty_1>())).ip6 as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceAddress__bindgen_ty_1),
        "::",
        stringify!(ip6)
        )
    );
}
#[test]
fn bindgen_test_layout__NiceAddress() {
    assert_eq!(
        ::std::mem::size_of::<_NiceAddress>(),
        28usize,
        concat!("Size of: ", stringify!(_NiceAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_NiceAddress>(),
        4usize,
        concat!("Alignment of ", stringify!(_NiceAddress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceAddress>())).s as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceAddress),
        "::",
        stringify!(s)
        )
    );
}
pub type NiceAddress = _NiceAddress;
extern "C" {
    #[doc = " nice_address_init:"]
    #[doc = " @addr: The #NiceAddress to init"]
    #[doc = ""]
    #[doc = " Initialize a #NiceAddress into an undefined address"]
    pub fn nice_address_init(addr: *mut NiceAddress);
}
extern "C" {
    #[doc = " nice_address_new:"]
    #[doc = ""]
    #[doc = " Create a new #NiceAddress with undefined address"]
    #[doc = " You must free it with nice_address_free()"]
    #[doc = ""]
    #[doc = " Returns: The new #NiceAddress"]
    pub fn nice_address_new() -> *mut NiceAddress;
}
extern "C" {
    #[doc = " nice_address_free:"]
    #[doc = " @addr: The #NiceAddress to free"]
    #[doc = ""]
    #[doc = " Frees a #NiceAddress created with nice_address_new() or nice_address_dup()"]
    pub fn nice_address_free(addr: *mut NiceAddress);
}
extern "C" {
    #[doc = " nice_address_dup:"]
    #[doc = " @addr: The #NiceAddress to dup"]
    #[doc = ""]
    #[doc = " Creates a new #NiceAddress with the same address as @addr"]
    #[doc = ""]
    #[doc = " Returns: The new #NiceAddress"]
    pub fn nice_address_dup(addr: *const NiceAddress) -> *mut NiceAddress;
}
extern "C" {
    #[doc = " nice_address_set_ipv4:"]
    #[doc = " @addr: The #NiceAddress to modify"]
    #[doc = " @addr_ipv4: The IPv4 address"]
    #[doc = ""]
    #[doc = " Set @addr to an IPv4 address using the data from @addr_ipv4"]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "This function will reset the port to 0, so make sure you call it before"]
    #[doc = "nice_address_set_port()"]
    #[doc = "</para>"]
    #[doc = "</note>"]
    pub fn nice_address_set_ipv4(addr: *mut NiceAddress, addr_ipv4: guint32);
}
extern "C" {
    #[doc = " nice_address_set_ipv6:"]
    #[doc = " @addr: The #NiceAddress to modify"]
    #[doc = " @addr_ipv6: The IPv6 address"]
    #[doc = ""]
    #[doc = " Set @addr to an IPv6 address using the data from @addr_ipv6"]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "This function will reset the port to 0, so make sure you call it before"]
    #[doc = "nice_address_set_port()"]
    #[doc = "</para>"]
    #[doc = "</note>"]
    pub fn nice_address_set_ipv6(addr: *mut NiceAddress, addr_ipv6: *const guchar);
}
extern "C" {
    #[doc = " nice_address_set_port:"]
    #[doc = " @addr: The #NiceAddress to modify"]
    #[doc = " @port: The port to set"]
    #[doc = ""]
    #[doc = " Set the port of @addr to @port"]
    pub fn nice_address_set_port(addr: *mut NiceAddress, port: guint);
}
extern "C" {
    #[doc = " nice_address_get_port:"]
    #[doc = " @addr: The #NiceAddress to query"]
    #[doc = ""]
    #[doc = " Retreive the port of @addr"]
    #[doc = ""]
    #[doc = " Returns: The port of @addr"]
    pub fn nice_address_get_port(addr: *const NiceAddress) -> guint;
}
extern "C" {
    #[doc = " nice_address_set_from_string:"]
    #[doc = " @addr: The #NiceAddress to modify"]
    #[doc = " @str: The string to set"]
    #[doc = ""]
    #[doc = " Sets an IPv4 or IPv6 address from the string @str"]
    #[doc = ""]
    #[doc = " Returns: %TRUE if success, %FALSE on error"]
    pub fn nice_address_set_from_string(addr: *mut NiceAddress, str: *const gchar) -> gboolean;
}
extern "C" {
    #[doc = " nice_address_set_from_sockaddr:"]
    #[doc = " @addr: The #NiceAddress to modify"]
    #[doc = " @sin: The sockaddr to set"]
    #[doc = ""]
    #[doc = " Sets an IPv4 or IPv6 address from the sockaddr structure @sin"]
    #[doc = ""]
    pub fn nice_address_set_from_sockaddr(addr: *mut NiceAddress, sin: *const sockaddr);
}
extern "C" {
    #[doc = " nice_address_copy_to_sockaddr:"]
    #[doc = " @addr: The #NiceAddress to query"]
    #[doc = " @sin: The sockaddr to fill"]
    #[doc = ""]
    #[doc = " Fills the sockaddr structure @sin with the address contained in @addr"]
    #[doc = ""]
    pub fn nice_address_copy_to_sockaddr(addr: *const NiceAddress, sin: *mut sockaddr);
}
extern "C" {
    #[doc = " nice_address_equal:"]
    #[doc = " @a: First #NiceAddress to compare"]
    #[doc = " @b: Second #NiceAddress to compare"]
    #[doc = ""]
    #[doc = " Compares two #NiceAddress structures to see if they contain the same address"]
    #[doc = " and the same port."]
    #[doc = ""]
    #[doc = " Returns: %TRUE if @a and @b are the same address, %FALSE if they are different"]
    pub fn nice_address_equal(a: *const NiceAddress, b: *const NiceAddress) -> gboolean;
}
extern "C" {
    #[doc = " nice_address_equal_no_port:"]
    #[doc = " @a: First #NiceAddress to compare"]
    #[doc = " @b: Second #NiceAddress to compare"]
    #[doc = ""]
    #[doc = " Compares two #NiceAddress structures to see if they contain the same address,"]
    #[doc = " ignoring the port."]
    #[doc = ""]
    #[doc = " Returns: %TRUE if @a and @b are the same address, %FALSE if they"]
    #[doc = " are different"]
    #[doc = ""]
    #[doc = " Since: 0.1.8"]
    pub fn nice_address_equal_no_port(a: *const NiceAddress, b: *const NiceAddress) -> gboolean;
}
extern "C" {
    #[doc = " nice_address_to_string:"]
    #[doc = " @addr: The #NiceAddress to query"]
    #[doc = " @dst: The string to fill"]
    #[doc = ""]
    #[doc = " Transforms the address @addr into a human readable string"]
    #[doc = ""]
    pub fn nice_address_to_string(addr: *const NiceAddress, dst: *mut gchar);
}
extern "C" {
    #[doc = " nice_address_is_private:"]
    #[doc = " @addr: The #NiceAddress to query"]
    #[doc = ""]
    #[doc = " Verifies if the address in @addr is a private address or not"]
    #[doc = ""]
    #[doc = " Returns: %TRUE if @addr is a private address, %FALSE otherwise"]
    pub fn nice_address_is_private(addr: *const NiceAddress) -> gboolean;
}
extern "C" {
    #[doc = " nice_address_is_valid:"]
    #[doc = " @addr: The #NiceAddress to query"]
    #[doc = ""]
    #[doc = " Validate whether the #NiceAddress @addr is a valid IPv4 or IPv6 address"]
    #[doc = ""]
    #[doc = " Returns: %TRUE if @addr is valid, %FALSE otherwise"]
    pub fn nice_address_is_valid(addr: *const NiceAddress) -> gboolean;
}
extern "C" {
    #[doc = " nice_address_ip_version:"]
    #[doc = " @addr: The #NiceAddress to query"]
    #[doc = ""]
    #[doc = " Returns the IP version of the address"]
    #[doc = ""]
    #[doc = " Returns: 4 for IPv4, 6 for IPv6 and 0 for undefined address"]
    pub fn nice_address_ip_version(addr: *const NiceAddress) -> ::std::os::raw::c_int;
}
pub const NiceCandidateType_NICE_CANDIDATE_TYPE_HOST: NiceCandidateType = 0;
pub const NiceCandidateType_NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE: NiceCandidateType = 1;
pub const NiceCandidateType_NICE_CANDIDATE_TYPE_PEER_REFLEXIVE: NiceCandidateType = 2;
pub const NiceCandidateType_NICE_CANDIDATE_TYPE_RELAYED: NiceCandidateType = 3;
#[doc = " NiceCandidateType:"]
#[doc = " @NICE_CANDIDATE_TYPE_HOST: A host candidate"]
#[doc = " @NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE: A server reflexive candidate"]
#[doc = " @NICE_CANDIDATE_TYPE_PEER_REFLEXIVE: A peer reflexive candidate"]
#[doc = " @NICE_CANDIDATE_TYPE_RELAYED: A relay candidate"]
#[doc = ""]
#[doc = " An enum represneting the type of a candidate"]
pub type NiceCandidateType = i32;
pub const NiceCandidateTransport_NICE_CANDIDATE_TRANSPORT_UDP: NiceCandidateTransport = 0;
pub const NiceCandidateTransport_NICE_CANDIDATE_TRANSPORT_TCP_ACTIVE: NiceCandidateTransport = 1;
pub const NiceCandidateTransport_NICE_CANDIDATE_TRANSPORT_TCP_PASSIVE: NiceCandidateTransport = 2;
pub const NiceCandidateTransport_NICE_CANDIDATE_TRANSPORT_TCP_SO: NiceCandidateTransport = 3;
#[doc = " NiceCandidateTransport:"]
#[doc = " @NICE_CANDIDATE_TRANSPORT_UDP: UDP transport"]
#[doc = " @NICE_CANDIDATE_TRANSPORT_TCP_ACTIVE: TCP Active transport"]
#[doc = " @NICE_CANDIDATE_TRANSPORT_TCP_PASSIVE: TCP Passive transport"]
#[doc = " @NICE_CANDIDATE_TRANSPORT_TCP_SO: TCP Simultaneous-Open transport"]
#[doc = ""]
#[doc = " An enum representing the type of transport to use"]
pub type NiceCandidateTransport = i32;
pub const NiceRelayType_NICE_RELAY_TYPE_TURN_UDP: NiceRelayType = 0;
pub const NiceRelayType_NICE_RELAY_TYPE_TURN_TCP: NiceRelayType = 1;
pub const NiceRelayType_NICE_RELAY_TYPE_TURN_TLS: NiceRelayType = 2;
#[doc = " NiceRelayType:"]
#[doc = " @NICE_RELAY_TYPE_TURN_UDP: A TURN relay using UDP"]
#[doc = " @NICE_RELAY_TYPE_TURN_TCP: A TURN relay using TCP"]
#[doc = " @NICE_RELAY_TYPE_TURN_TLS: A TURN relay using TLS over TCP"]
#[doc = ""]
#[doc = " An enum representing the type of relay to use"]
pub type NiceRelayType = i32;
pub type NiceCandidate = _NiceCandidate;
#[doc = " NiceCandidate:"]
#[doc = " @type: The type of candidate"]
#[doc = " @transport: The transport being used for the candidate"]
#[doc = " @addr: The #NiceAddress of the candidate"]
#[doc = " @base_addr: The #NiceAddress of the base address used by the candidate"]
#[doc = " @priority: The priority of the candidate <emphasis> see note </emphasis>"]
#[doc = " @stream_id: The ID of the stream to which belongs the candidate"]
#[doc = " @component_id: The ID of the component to which belongs the candidate"]
#[doc = " @foundation: The foundation of the candidate"]
#[doc = " @username: The candidate-specific username to use (overrides the one set"]
#[doc = " by nice_agent_set_local_credentials() or nice_agent_set_remote_credentials())"]
#[doc = " @password: The candidate-specific password to use (overrides the one set"]
#[doc = " by nice_agent_set_local_credentials() or nice_agent_set_remote_credentials())"]
#[doc = ""]
#[doc = " A structure to represent an ICE candidate"]
#[doc = "<note>"]
#[doc = "<para>"]
#[doc = "The @priority is an integer as specified in the ICE draft 19. If you are"]
#[doc = "using the MSN or the GOOGLE compatibility mode (which are based on ICE"]
#[doc = "draft 6, which uses a floating point qvalue as priority), then the @priority"]
#[doc = "value will represent the qvalue multiplied by 1000."]
#[doc = "</para>"]
#[doc = "</note>"]
#[repr(C)]
pub struct _NiceCandidate {
    pub type_: NiceCandidateType,
    pub transport: NiceCandidateTransport,
    pub addr: NiceAddress,
    pub base_addr: NiceAddress,
    pub priority: guint32,
    pub stream_id: guint,
    pub component_id: guint,
    pub foundation: [gchar; 33usize],
    pub username: *mut gchar,
    pub password: *mut gchar,
}
#[test]
fn bindgen_test_layout__NiceCandidate() {
    assert_eq!(
        ::std::mem::size_of::<_NiceCandidate>(),
        128usize,
        concat!("Size of: ", stringify!(_NiceCandidate))
    );
    assert_eq!(
        ::std::mem::align_of::<_NiceCandidate>(),
        8usize,
        concat!("Alignment of ", stringify!(_NiceCandidate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).type_ as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceCandidate),
        "::",
        stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).transport as *const _ as usize },
        4usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceCandidate),
        "::",
        stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).addr as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceCandidate),
        "::",
        stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).base_addr as *const _ as usize },
        36usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceCandidate),
        "::",
        stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).priority as *const _ as usize },
        64usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceCandidate),
        "::",
        stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).stream_id as *const _ as usize },
        68usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceCandidate),
        "::",
        stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).component_id as *const _ as usize },
        72usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceCandidate),
        "::",
        stringify!(component_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).foundation as *const _ as usize },
        76usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceCandidate),
        "::",
        stringify!(foundation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).username as *const _ as usize },
        112usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceCandidate),
        "::",
        stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).password as *const _ as usize },
        120usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceCandidate),
        "::",
        stringify!(password)
        )
    );
}
extern "C" {
    #[doc = " nice_candidate_new:"]
    #[doc = " @type: The #NiceCandidateType of the candidate to create"]
    #[doc = ""]
    #[doc = " Creates a new candidate. Must be freed with nice_candidate_free()"]
    #[doc = ""]
    #[doc = " Returns: A new #NiceCandidate"]
    pub fn nice_candidate_new(type_: NiceCandidateType) -> *mut NiceCandidate;
}
extern "C" {
    #[doc = " nice_candidate_free:"]
    #[doc = " @candidate: The candidate to free"]
    #[doc = ""]
    #[doc = " Frees a #NiceCandidate"]
    pub fn nice_candidate_free(candidate: *mut NiceCandidate);
}
extern "C" {
    #[doc = " nice_candidate_copy:"]
    #[doc = " @candidate: The candidate to copy"]
    #[doc = ""]
    #[doc = " Makes a copy of a #NiceCandidate"]
    #[doc = ""]
    #[doc = " Returns: A new #NiceCandidate, a copy of @candidate"]
    pub fn nice_candidate_copy(candidate: *const NiceCandidate) -> *mut NiceCandidate;
}
extern "C" {
    #[doc = " nice_candidate_equal_target:"]
    #[doc = " @candidate1: A candidate"]
    #[doc = " @candidate2: A candidate"]
    #[doc = ""]
    #[doc = " Verifies that the candidates point to the same place, meaning they have"]
    #[doc = " the same transport and the same address. It ignores all other aspects."]
    #[doc = ""]
    #[doc = " Returns: %TRUE if the candidates point to the same place"]
    #[doc = ""]
    #[doc = " Since: 0.1.15"]
    pub fn nice_candidate_equal_target(
        candidate1: *const NiceCandidate,
        candidate2: *const NiceCandidate,
    ) -> gboolean;
}
extern "C" {
    pub fn nice_candidate_get_type() -> GType;
}
extern "C" {
    #[doc = " nice_candidate_type_to_string:"]
    #[doc = " @type: a #NiceCandidateType"]
    #[doc = ""]
    #[doc = " Useful for debugging functions, just returns a static string with the"]
    #[doc = " candidate type."]
    #[doc = ""]
    #[doc = " Returns: a static string with the candidate type"]
    #[doc = ""]
    #[doc = " Since: 0.1.18"]
    pub fn nice_candidate_type_to_string(type_: NiceCandidateType) -> *const gchar;
}
extern "C" {
    #[doc = " nice_candidate_transport_to_string:"]
    #[doc = " @transport: a #NiceCandidateTransport"]
    #[doc = ""]
    #[doc = " Useful for debugging functions, just returns a static string with the"]
    #[doc = " candidate transport."]
    #[doc = ""]
    #[doc = " Returns: a static string with the candidate transport"]
    #[doc = ""]
    #[doc = " Since: 0.1.18"]
    pub fn nice_candidate_transport_to_string(transport: NiceCandidateTransport) -> *const gchar;
}
extern "C" {
    #[doc = " nice_debug_enable:"]
    #[doc = " @with_stun: Also enable STUN debugging messages"]
    #[doc = ""]
    #[doc = " Enables libnice debug output to the terminal. Note that the"]
    #[doc = " `G_MESSAGES_DEBUG` and `NICE_DEBUG` environment variables must be set to the"]
    #[doc = " set of logging domains to print, in order for any output to be printed. Set"]
    #[doc = " them to `all` to print all debugging messages, or any of the following"]
    #[doc = " domains:"]
    #[doc = " - `libnice-stun`"]
    #[doc = " - `libnice-tests`"]
    #[doc = " - `libnice-socket`"]
    #[doc = " - `libnice`"]
    #[doc = " - `libnice-pseudotcp`"]
    #[doc = " - `libnice-pseudotcp-verbose`"]
    pub fn nice_debug_enable(with_stun: gboolean);
}
extern "C" {
    #[doc = " nice_debug_disable:"]
    #[doc = " @with_stun: Also disable stun debugging messages"]
    #[doc = ""]
    #[doc = " Disables libnice debug output to the terminal"]
    pub fn nice_debug_disable(with_stun: gboolean);
}
#[doc = " NiceInputMessage:"]
#[doc = " @buffers: (array length=n_buffers): unowned array of #GInputVector buffers to"]
#[doc = " store data in for this message"]
#[doc = " @n_buffers: number of #GInputVectors in @buffers, or -1 to indicate @buffers"]
#[doc = " is %NULL-terminated"]
#[doc = " @from: (allow-none): return location to store the address of the peer who"]
#[doc = " transmitted the message, or %NULL"]
#[doc = " @length: total number of valid bytes contiguously stored in @buffers"]
#[doc = ""]
#[doc = " Represents a single message received off the network. For reliable"]
#[doc = " connections, this is essentially just an array of buffers (specifically,"]
#[doc = " @from can be ignored). for non-reliable connections, it represents a single"]
#[doc = " packet as received from the OS."]
#[doc = ""]
#[doc = " @n_buffers may be -1 to indicate that @buffers is terminated by a"]
#[doc = " #GInputVector with a %NULL buffer pointer."]
#[doc = ""]
#[doc = " By providing arrays of #NiceInputMessages to functions like"]
#[doc = " nice_agent_recv_messages(), multiple messages may be received with a single"]
#[doc = " call, which is more efficient than making multiple calls in a loop. In this"]
#[doc = " manner, nice_agent_recv_messages() is analogous to recvmmsg(); and"]
#[doc = " #NiceInputMessage to struct mmsghdr."]
#[doc = ""]
#[doc = " Since: 0.1.5"]
#[repr(C)]
pub struct NiceInputMessage {
    pub buffers: *mut GInputVector,
    pub n_buffers: gint,
    pub from: *mut NiceAddress,
    pub length: gsize,
}
#[test]
fn bindgen_test_layout_NiceInputMessage() {
    assert_eq!(
        ::std::mem::size_of::<NiceInputMessage>(),
        32usize,
        concat!("Size of: ", stringify!(NiceInputMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<NiceInputMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(NiceInputMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceInputMessage>())).buffers as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(NiceInputMessage),
        "::",
        stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceInputMessage>())).n_buffers as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(NiceInputMessage),
        "::",
        stringify!(n_buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceInputMessage>())).from as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(NiceInputMessage),
        "::",
        stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceInputMessage>())).length as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(NiceInputMessage),
        "::",
        stringify!(length)
        )
    );
}
#[doc = " NiceOutputMessage:"]
#[doc = " @buffers: (array length=n_buffers): unowned array of #GOutputVector buffers"]
#[doc = " which contain data to transmit for this message"]
#[doc = " @n_buffers: number of #GOutputVectors in @buffers, or -1 to indicate @buffers"]
#[doc = " is %NULL-terminated"]
#[doc = ""]
#[doc = " Represents a single message to transmit on the network. For"]
#[doc = " reliable connections, this is essentially just an array of"]
#[doc = " buffer. for non-reliable connections, it represents a single packet"]
#[doc = " to send to the OS."]
#[doc = ""]
#[doc = " @n_buffers may be -1 to indicate that @buffers is terminated by a"]
#[doc = " #GOutputVector with a %NULL buffer pointer."]
#[doc = ""]
#[doc = " By providing arrays of #NiceOutputMessages to functions like"]
#[doc = " nice_agent_send_messages_nonblocking(), multiple messages may be transmitted"]
#[doc = " with a single call, which is more efficient than making multiple calls in a"]
#[doc = " loop. In this manner, nice_agent_send_messages_nonblocking() is analogous to"]
#[doc = " sendmmsg(); and #NiceOutputMessage to struct mmsghdr."]
#[doc = ""]
#[doc = " Since: 0.1.5"]
#[repr(C)]
pub struct NiceOutputMessage {
    pub buffers: *mut GOutputVector,
    pub n_buffers: gint,
}
#[test]
fn bindgen_test_layout_NiceOutputMessage() {
    assert_eq!(
        ::std::mem::size_of::<NiceOutputMessage>(),
        16usize,
        concat!("Size of: ", stringify!(NiceOutputMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<NiceOutputMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(NiceOutputMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceOutputMessage>())).buffers as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(NiceOutputMessage),
        "::",
        stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceOutputMessage>())).n_buffers as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(NiceOutputMessage),
        "::",
        stringify!(n_buffers)
        )
    );
}
pub type NiceAgentClass = _NiceAgentClass;
#[repr(C)]
pub struct _NiceAgentClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__NiceAgentClass() {
    assert_eq!(
        ::std::mem::size_of::<_NiceAgentClass>(),
        136usize,
        concat!("Size of: ", stringify!(_NiceAgentClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_NiceAgentClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_NiceAgentClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceAgentClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_NiceAgentClass),
        "::",
        stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn nice_agent_get_type() -> GType;
}
pub const NiceComponentState_NICE_COMPONENT_STATE_DISCONNECTED: NiceComponentState = 0;
pub const NiceComponentState_NICE_COMPONENT_STATE_GATHERING: NiceComponentState = 1;
pub const NiceComponentState_NICE_COMPONENT_STATE_CONNECTING: NiceComponentState = 2;
pub const NiceComponentState_NICE_COMPONENT_STATE_CONNECTED: NiceComponentState = 3;
pub const NiceComponentState_NICE_COMPONENT_STATE_READY: NiceComponentState = 4;
pub const NiceComponentState_NICE_COMPONENT_STATE_FAILED: NiceComponentState = 5;
pub const NiceComponentState_NICE_COMPONENT_STATE_LAST: NiceComponentState = 6;
#[doc = " NiceComponentState:"]
#[doc = " @NICE_COMPONENT_STATE_DISCONNECTED: No activity scheduled"]
#[doc = " @NICE_COMPONENT_STATE_GATHERING: Gathering local candidates"]
#[doc = " @NICE_COMPONENT_STATE_CONNECTING: Establishing connectivity"]
#[doc = " @NICE_COMPONENT_STATE_CONNECTED: At least one working candidate pair"]
#[doc = " @NICE_COMPONENT_STATE_READY: ICE concluded, candidate pair selection"]
#[doc = " is now final"]
#[doc = " @NICE_COMPONENT_STATE_FAILED: Connectivity checks have been completed,"]
#[doc = " but connectivity was not established"]
#[doc = " @NICE_COMPONENT_STATE_LAST: Dummy state"]
#[doc = ""]
#[doc = " An enum representing the state of a component."]
#[doc = " <para> See also: #NiceAgent::component-state-changed </para>"]
pub type NiceComponentState = i32;
pub const NiceComponentType_NICE_COMPONENT_TYPE_RTP: NiceComponentType = 1;
pub const NiceComponentType_NICE_COMPONENT_TYPE_RTCP: NiceComponentType = 2;
#[doc = " NiceComponentType:"]
#[doc = " @NICE_COMPONENT_TYPE_RTP: RTP Component type"]
#[doc = " @NICE_COMPONENT_TYPE_RTCP: RTCP Component type"]
#[doc = ""]
#[doc = " Convenience enum representing the type of a component for use as the"]
#[doc = " component_id for RTP/RTCP usages."]
#[doc = "<example>"]
#[doc = "<title>Example of use.</title>"]
#[doc = "<programlisting>"]
#[doc = "nice_agent_send (agent, stream_id, NICE_COMPONENT_TYPE_RTP, len, buf);"]
#[doc = "</programlisting>"]
#[doc = "</example>"]
pub type NiceComponentType = i32;
pub const NiceCompatibility_NICE_COMPATIBILITY_RFC5245: NiceCompatibility = 0;
pub const NiceCompatibility_NICE_COMPATIBILITY_DRAFT19: NiceCompatibility = 0;
pub const NiceCompatibility_NICE_COMPATIBILITY_GOOGLE: NiceCompatibility = 1;
pub const NiceCompatibility_NICE_COMPATIBILITY_MSN: NiceCompatibility = 2;
pub const NiceCompatibility_NICE_COMPATIBILITY_WLM2009: NiceCompatibility = 3;
pub const NiceCompatibility_NICE_COMPATIBILITY_OC2007: NiceCompatibility = 4;
pub const NiceCompatibility_NICE_COMPATIBILITY_OC2007R2: NiceCompatibility = 5;
pub const NiceCompatibility_NICE_COMPATIBILITY_LAST: NiceCompatibility = 5;
#[doc = " NiceCompatibility:"]
#[doc = " @NICE_COMPATIBILITY_RFC5245: Use compatibility with the RFC5245 ICE-UDP specs"]
#[doc = " and RFC6544 ICE-TCP specs"]
#[doc = " @NICE_COMPATIBILITY_GOOGLE: Use compatibility for Google Talk specs"]
#[doc = " @NICE_COMPATIBILITY_MSN: Use compatibility for MSN Messenger specs"]
#[doc = " @NICE_COMPATIBILITY_WLM2009: Use compatibility with Windows Live Messenger"]
#[doc = " 2009"]
#[doc = " @NICE_COMPATIBILITY_OC2007: Use compatibility with Microsoft Office Communicator 2007"]
#[doc = " @NICE_COMPATIBILITY_OC2007R2: Use compatibility with Microsoft Office Communicator 2007 R2"]
#[doc = " @NICE_COMPATIBILITY_DRAFT19: Use compatibility for ICE Draft 19 specs"]
#[doc = " @NICE_COMPATIBILITY_LAST: Dummy last compatibility mode"]
#[doc = ""]
#[doc = " An enum to specify which compatible specifications the #NiceAgent should use."]
#[doc = " Use with nice_agent_new()"]
#[doc = ""]
#[doc = " <warning>@NICE_COMPATIBILITY_DRAFT19 is deprecated and should not be used"]
#[doc = " in newly-written code. It is kept for compatibility reasons and"]
#[doc = " represents the same compatibility as @NICE_COMPATIBILITY_RFC5245 </warning>"]
#[doc = "<note>"]
#[doc = "<para>"]
#[doc = "If @NICE_COMPATIBILITY_RFC5245 compatibility mode is used for a non-reliable"]
#[doc = "agent, then ICE-UDP will be used with higher priority and ICE-TCP will also"]
#[doc = "be used when the UDP connectivity fails. If it is used with a reliable agent,"]
#[doc = "then ICE-UDP will be used with the TCP-Over-UDP (#PseudoTcpSocket) if ICE-TCP"]
#[doc = "fails and ICE-UDP succeeds."]
#[doc = "</para>"]
#[doc = "</note>"]
#[doc = ""]
pub type NiceCompatibility = i32;
pub const NiceProxyType_NICE_PROXY_TYPE_NONE: NiceProxyType = 0;
pub const NiceProxyType_NICE_PROXY_TYPE_SOCKS5: NiceProxyType = 1;
pub const NiceProxyType_NICE_PROXY_TYPE_HTTP: NiceProxyType = 2;
pub const NiceProxyType_NICE_PROXY_TYPE_LAST: NiceProxyType = 2;
#[doc = " NiceProxyType:"]
#[doc = " @NICE_PROXY_TYPE_NONE: Do not use a proxy"]
#[doc = " @NICE_PROXY_TYPE_SOCKS5: Use a SOCKS5 proxy"]
#[doc = " @NICE_PROXY_TYPE_HTTP: Use an HTTP proxy"]
#[doc = " @NICE_PROXY_TYPE_LAST: Dummy last proxy type"]
#[doc = ""]
#[doc = " An enum to specify which proxy type to use for relaying."]
#[doc = " Note that the proxies will only be used with TCP TURN relaying."]
#[doc = " <para> See also: #NiceAgent:proxy-type </para>"]
#[doc = ""]
#[doc = " Since: 0.0.4"]
pub type NiceProxyType = i32;
pub const NiceNominationMode_NICE_NOMINATION_MODE_REGULAR: NiceNominationMode = 0;
pub const NiceNominationMode_NICE_NOMINATION_MODE_AGGRESSIVE: NiceNominationMode = 1;
#[doc = " NiceNominationMode:"]
#[doc = " @NICE_NOMINATION_MODE_AGGRESSIVE: Aggressive nomination mode"]
#[doc = " @NICE_NOMINATION_MODE_REGULAR: Regular nomination mode"]
#[doc = ""]
#[doc = " An enum to specity the kind of nomination mode to use by"]
#[doc = " the agent, as described in RFC 5245. Two modes exists,"]
#[doc = " regular and aggressive. They differ by the way the controlling"]
#[doc = " agent chooses to put the USE-CANDIDATE attribute in its STUN"]
#[doc = " messages. The aggressive mode is supposed to nominate a pair"]
#[doc = " faster, than the regular mode, potentially causing the nominated"]
#[doc = " pair to change until the connection check completes."]
#[doc = ""]
#[doc = " Since: 0.1.15"]
pub type NiceNominationMode = i32;
pub const NiceAgentOption_NICE_AGENT_OPTION_REGULAR_NOMINATION: NiceAgentOption = 1;
pub const NiceAgentOption_NICE_AGENT_OPTION_RELIABLE: NiceAgentOption = 2;
pub const NiceAgentOption_NICE_AGENT_OPTION_LITE_MODE: NiceAgentOption = 4;
pub const NiceAgentOption_NICE_AGENT_OPTION_ICE_TRICKLE: NiceAgentOption = 8;
pub const NiceAgentOption_NICE_AGENT_OPTION_SUPPORT_RENOMINATION: NiceAgentOption = 16;
#[doc = " NiceAgentOption:"]
#[doc = " @NICE_AGENT_OPTION_REGULAR_NOMINATION: Enables regular nomination, default"]
#[doc = "  is aggrssive mode (see #NiceNominationMode)."]
#[doc = " @NICE_AGENT_OPTION_RELIABLE: Enables reliable mode, possibly using PseudoTCP, *  see nice_agent_new_reliable()."]
#[doc = " @NICE_AGENT_OPTION_LITE_MODE: Enable lite mode"]
#[doc = " @NICE_AGENT_OPTION_ICE_TRICKLE: Enable ICE trickle mode"]
#[doc = " @NICE_AGENT_OPTION_SUPPORT_RENOMINATION: Enable renomination triggered by NOMINATION STUN attribute"]
#[doc = " proposed here: https://tools.ietf.org/html/draft-thatcher-ice-renomination-00"]
#[doc = ""]
#[doc = " These are options that can be passed to nice_agent_new_full(). They set"]
#[doc = " various properties on the agent. Not including them sets the property to"]
#[doc = " the other value."]
#[doc = ""]
#[doc = " Since: 0.1.15"]
pub type NiceAgentOption = i32;
#[doc = " NiceAgentRecvFunc:"]
#[doc = " @agent: The #NiceAgent Object"]
#[doc = " @stream_id: The id of the stream"]
#[doc = " @component_id: The id of the component of the stream"]
#[doc = "        which received the data"]
#[doc = " @len: The length of the data"]
#[doc = " @buf: The buffer containing the data received"]
#[doc = " @user_data: The user data set in nice_agent_attach_recv()"]
#[doc = ""]
#[doc = " Callback function when data is received on a component"]
#[doc = ""]
pub type NiceAgentRecvFunc = ::std::option::Option<
    unsafe extern "C" fn(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        len: guint,
        buf: *mut gchar,
        user_data: gpointer,
    ),
>;
extern "C" {
    #[doc = " nice_agent_new:"]
    #[doc = " @ctx: The Glib Mainloop Context to use for timers"]
    #[doc = " @compat: The compatibility mode of the agent"]
    #[doc = ""]
    #[doc = " Create a new #NiceAgent."]
    #[doc = " The returned object must be freed with g_object_unref()"]
    #[doc = ""]
    #[doc = " Returns: The new agent GObject"]
    pub fn nice_agent_new(ctx: *mut GMainContext, compat: NiceCompatibility) -> *mut NiceAgent;
}
extern "C" {
    #[doc = " nice_agent_new_reliable:"]
    #[doc = " @ctx: The Glib Mainloop Context to use for timers"]
    #[doc = " @compat: The compatibility mode of the agent"]
    #[doc = ""]
    #[doc = " Create a new #NiceAgent in reliable mode. If the connectivity is established"]
    #[doc = " through ICE-UDP, then a #PseudoTcpSocket will be transparently used to"]
    #[doc = " ensure reliability of the messages."]
    #[doc = " The returned object must be freed with g_object_unref()"]
    #[doc = " <para> See also: #NiceAgent::reliable-transport-writable </para>"]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    #[doc = ""]
    #[doc = " Returns: The new agent GObject"]
    pub fn nice_agent_new_reliable(
        ctx: *mut GMainContext,
        compat: NiceCompatibility,
    ) -> *mut NiceAgent;
}
extern "C" {
    #[doc = " nice_agent_new_full:"]
    #[doc = " @ctx: The Glib Mainloop Context to use for timers"]
    #[doc = " @compat: The compatibility mode of the agent"]
    #[doc = " @flags: Flags to set the properties"]
    #[doc = ""]
    #[doc = " Create a new #NiceAgent with parameters that must be be defined at"]
    #[doc = " construction time."]
    #[doc = " The returned object must be freed with g_object_unref()"]
    #[doc = " <para> See also: #NiceNominationMode and #NiceAgentOption</para>"]
    #[doc = ""]
    #[doc = " Since: 0.1.15"]
    #[doc = ""]
    #[doc = " Returns: The new agent GObject"]
    pub fn nice_agent_new_full(
        ctx: *mut GMainContext,
        compat: NiceCompatibility,
        flags: NiceAgentOption,
    ) -> *mut NiceAgent;
}
extern "C" {
    #[doc = " nice_agent_add_local_address:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @addr: The address to listen to"]
    #[doc = " If the port is 0, then a random port will be chosen by the system"]
    #[doc = ""]
    #[doc = " Add a local address from which to derive local host candidates for"]
    #[doc = " candidate gathering."]
    #[doc = " <para>"]
    #[doc = " Since 0.0.5, if this method is not called, libnice will automatically"]
    #[doc = " discover the local addresses available"]
    #[doc = " </para>"]
    #[doc = ""]
    #[doc = " See also: nice_agent_gather_candidates()"]
    #[doc = " Returns: %TRUE on success, %FALSE on fatal (memory allocation) errors"]
    pub fn nice_agent_add_local_address(agent: *mut NiceAgent, addr: *mut NiceAddress) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_add_stream:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @n_components: The number of components to add to the stream"]
    #[doc = ""]
    #[doc = " Adds a data stream to @agent containing @n_components components. The"]
    #[doc = " returned stream ID is guaranteed to be positive on success."]
    #[doc = ""]
    #[doc = " Returns: The ID of the new stream, 0 on failure"]
    pub fn nice_agent_add_stream(agent: *mut NiceAgent, n_components: guint) -> guint;
}
extern "C" {
    #[doc = " nice_agent_remove_stream:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream to remove"]
    #[doc = ""]
    #[doc = " Remove and free a previously created data stream from @agent. If any I/O"]
    #[doc = " streams have been created using nice_agent_get_io_stream(), they should be"]
    #[doc = " closed completely using g_io_stream_close() before this is called, or they"]
    #[doc = " will get broken pipe errors."]
    #[doc = ""]
    pub fn nice_agent_remove_stream(agent: *mut NiceAgent, stream_id: guint);
}
extern "C" {
    #[doc = " nice_agent_set_port_range:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = " @min_port: The minimum port to use"]
    #[doc = " @max_port: The maximum port to use"]
    #[doc = ""]
    #[doc = " Sets a preferred port range for allocating host candidates."]
    #[doc = " <para>"]
    #[doc = " If a local host candidate cannot be created on that port"]
    #[doc = " range, then the nice_agent_gather_candidates() call will fail."]
    #[doc = " </para>"]
    #[doc = " <para>"]
    #[doc = " This MUST be called before nice_agent_gather_candidates()"]
    #[doc = " </para>"]
    #[doc = ""]
    pub fn nice_agent_set_port_range(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        min_port: guint,
        max_port: guint,
    );
}
extern "C" {
    #[doc = " nice_agent_set_relay_info:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = " @server_ip: The IP address of the TURN server"]
    #[doc = " @server_port: The port of the TURN server"]
    #[doc = " @username: The TURN username to use for the allocate"]
    #[doc = " @password: The TURN password to use for the allocate"]
    #[doc = " @type: The type of relay to use"]
    #[doc = ""]
    #[doc = " Sets the settings for using a relay server during the candidate discovery."]
    #[doc = " This may be called multiple times to add multiple relay servers to the"]
    #[doc = " discovery process; one TCP and one UDP, for example."]
    #[doc = ""]
    #[doc = " Returns: %TRUE if the TURN settings were accepted."]
    #[doc = " %FALSE if the address was invalid."]
    pub fn nice_agent_set_relay_info(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        server_ip: *const gchar,
        server_port: guint,
        username: *const gchar,
        password: *const gchar,
        type_: NiceRelayType,
    ) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_gather_candidates:"]
    #[doc = " @agent: The #NiceAgent object"]
    #[doc = " @stream_id: The ID of the stream to start"]
    #[doc = ""]
    #[doc = " Allocate and start listening on local candidate ports and start the remote"]
    #[doc = " candidate gathering process."]
    #[doc = " Once done, #NiceAgent::candidate-gathering-done is called for the stream."]
    #[doc = " As soon as this function is called, #NiceAgent::new-candidate signals may be"]
    #[doc = " emitted, even before this function returns."]
    #[doc = ""]
    #[doc = " nice_agent_get_local_candidates() will only return non-empty results after"]
    #[doc = " calling this function."]
    #[doc = ""]
    #[doc = " <para>See also: nice_agent_add_local_address()</para>"]
    #[doc = " <para>See also: nice_agent_set_port_range()</para>"]
    #[doc = ""]
    #[doc = " Returns: %FALSE if the stream ID is invalid or if a host candidate couldn't"]
    #[doc = " be allocated on the requested interfaces/ports; %TRUE otherwise"]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "Local addresses can be previously set with nice_agent_add_local_address()"]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "Since 0.0.5, If no local address was previously added, then the nice agent"]
    #[doc = "will automatically detect the local address using"]
    #[doc = "nice_interfaces_get_local_ips()"]
    #[doc = "</para>"]
    #[doc = "</note>"]
    pub fn nice_agent_gather_candidates(agent: *mut NiceAgent, stream_id: guint) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_set_remote_credentials:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @ufrag: nul-terminated string containing an ICE username fragment"]
    #[doc = "    (length must be between 22 and 256 chars)"]
    #[doc = " @pwd: nul-terminated string containing an ICE password"]
    #[doc = "    (length must be between 4 and 256 chars)"]
    #[doc = ""]
    #[doc = " Sets the remote credentials for stream @stream_id."]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "Stream credentials do not override per-candidate credentials if set"]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "Due to the native of peer-reflexive candidates, any agent using a per-stream"]
    #[doc = "credentials (RFC5245, WLM2009, OC2007R2 and DRAFT19) instead of"]
    #[doc = "per-candidate credentials (GOOGLE, MSN, OC2007), must"]
    #[doc = "use the nice_agent_set_remote_credentials() API instead of setting the"]
    #[doc = "username and password on the candidates."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Returns: %TRUE on success, %FALSE on error."]
    pub fn nice_agent_set_remote_credentials(
        agent: *mut NiceAgent,
        stream_id: guint,
        ufrag: *const gchar,
        pwd: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_set_local_credentials:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @ufrag: nul-terminated string containing an ICE username fragment"]
    #[doc = "    (length must be between 22 and 256 chars)"]
    #[doc = " @pwd: nul-terminated string containing an ICE password"]
    #[doc = "    (length must be between 4 and 256 chars)"]
    #[doc = ""]
    #[doc = " Sets the local credentials for stream @stream_id."]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "This is only effective before ICE negotiation has started."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Since 0.1.11"]
    #[doc = " Returns: %TRUE on success, %FALSE on error."]
    pub fn nice_agent_set_local_credentials(
        agent: *mut NiceAgent,
        stream_id: guint,
        ufrag: *const gchar,
        pwd: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_get_local_credentials:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @ufrag: (out callee-allocates): return location for a nul-terminated string"]
    #[doc = " containing an ICE username fragment; must be freed with g_free()"]
    #[doc = " @pwd: (out callee-allocates): return location for a nul-terminated string"]
    #[doc = " containing an ICE password; must be freed with g_free()"]
    #[doc = ""]
    #[doc = " Gets the local credentials for stream @stream_id. This may be called any time"]
    #[doc = " after creating a stream using nice_agent_add_stream()."]
    #[doc = ""]
    #[doc = " An error will be returned if this is called for a non-existent stream, or if"]
    #[doc = " either of @ufrag or @pwd are %NULL."]
    #[doc = ""]
    #[doc = " Returns: %TRUE on success, %FALSE on error."]
    pub fn nice_agent_get_local_credentials(
        agent: *mut NiceAgent,
        stream_id: guint,
        ufrag: *mut *mut gchar,
        pwd: *mut *mut gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_set_remote_candidates:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream the candidates are for"]
    #[doc = " @component_id: The ID of the component the candidates are for"]
    #[doc = " @candidates: (element-type NiceCandidate) (transfer none): a #GSList of"]
    #[doc = " #NiceCandidate items describing each candidate to add"]
    #[doc = ""]
    #[doc = " Sets, adds or updates the remote candidates for a component of a stream."]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "NICE_AGENT_MAX_REMOTE_CANDIDATES is the absolute maximum limit"]
    #[doc = "for remote candidates."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "You must first call nice_agent_gather_candidates() and wait for the"]
    #[doc = "#NiceAgent::candidate-gathering-done signale before"]
    #[doc = "calling nice_agent_set_remote_candidates()"]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "Since 0.1.3, there is no need to wait for the candidate-gathering-done signal."]
    #[doc = "Remote candidates can be set even while gathering local candidates."]
    #[doc = "Newly discovered local candidates will automatically be paired with"]
    #[doc = "existing remote candidates."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Returns: The number of candidates added, negative on errors (memory"]
    #[doc = " allocation error or invalid component)"]
    pub fn nice_agent_set_remote_candidates(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        candidates: *const GSList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " nice_agent_send:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream to send to"]
    #[doc = " @component_id: The ID of the component to send to"]
    #[doc = " @len: The length of the buffer to send"]
    #[doc = " @buf: The buffer of data to send"]
    #[doc = ""]
    #[doc = " Sends a data payload over a stream's component."]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "Component state MUST be NICE_COMPONENT_STATE_READY, or as a special case,"]
    #[doc = "in any state if component was in READY state before and was then restarted"]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "In reliable mode, the -1 error value means either that you are not yet"]
    #[doc = "connected or that the send buffer is full (equivalent to EWOULDBLOCK)."]
    #[doc = "In both cases, you simply need to wait for the"]
    #[doc = "#NiceAgent::reliable-transport-writable signal to be fired before resending"]
    #[doc = "the data."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "In non-reliable mode, it will virtually never happen with UDP sockets, but"]
    #[doc = "it might happen if the active candidate is a TURN-TCP connection that got"]
    #[doc = "disconnected."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "In both reliable and non-reliable mode, a -1 error code could also mean that"]
    #[doc = "the stream_id and/or component_id are invalid."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Returns: The number of bytes sent, or negative error code"]
    pub fn nice_agent_send(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        len: guint,
        buf: *const gchar,
    ) -> gint;
}
extern "C" {
    #[doc = " nice_agent_send_messages_nonblocking:"]
    #[doc = " @agent: a #NiceAgent"]
    #[doc = " @stream_id: the ID of the stream to send to"]
    #[doc = " @component_id: the ID of the component to send to"]
    #[doc = " @messages: (array length=n_messages): array of messages to send, of at least"]
    #[doc = " @n_messages entries in length"]
    #[doc = " @n_messages: number of entries in @messages"]
    #[doc = " @cancellable: (allow-none): a #GCancellable to cancel the operation from"]
    #[doc = " another thread, or %NULL"]
    #[doc = " @error: (allow-none): return location for a #GError, or %NULL"]
    #[doc = ""]
    #[doc = " Sends multiple messages on the socket identified by the given"]
    #[doc = " stream/component pair. Transmission is non-blocking, so a"]
    #[doc = " %G_IO_ERROR_WOULD_BLOCK error may be returned if the send buffer is full."]
    #[doc = ""]
    #[doc = " As with nice_agent_send(), the given component must be in"]
    #[doc = " %NICE_COMPONENT_STATE_READY or, as a special case, in any state if it was"]
    #[doc = " previously ready and was then restarted."]
    #[doc = ""]
    #[doc = " On success, the number of messages written to the socket will be returned,"]
    #[doc = " which may be less than @n_messages if transmission would have blocked"]
    #[doc = " part-way through. Zero will be returned if @n_messages is zero, or if"]
    #[doc = " transmission would have blocked on the first message."]
    #[doc = ""]
    #[doc = " In reliable mode, it is instead recommended to use"]
    #[doc = " nice_agent_send().  The return value can be less than @n_messages"]
    #[doc = " or 0 even if it is still possible to send a partial message. In"]
    #[doc = " this case, \"nice-agent-writable\" will never be triggered, so the"]
    #[doc = " application would have to use nice_agent_sent() to fill the buffer or have"]
    #[doc = " to retry sending at a later point."]
    #[doc = ""]
    #[doc = " On failure, -1 will be returned and @error will be set. If the #NiceAgent is"]
    #[doc = " reliable and the socket is not yet connected, %G_IO_ERROR_BROKEN_PIPE will be"]
    #[doc = " returned; if the write buffer is full, %G_IO_ERROR_WOULD_BLOCK will be"]
    #[doc = " returned. In both cases, wait for the #NiceAgent::reliable-transport-writable"]
    #[doc = " signal before trying again. If the given @stream_id or @component_id are"]
    #[doc = " invalid or not yet connected, %G_IO_ERROR_BROKEN_PIPE will be returned."]
    #[doc = " %G_IO_ERROR_FAILED will be returned for other errors."]
    #[doc = ""]
    #[doc = " Returns: the number of messages sent (may be zero), or -1 on error"]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn nice_agent_send_messages_nonblocking(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        messages: *const NiceOutputMessage,
        n_messages: guint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    #[doc = " nice_agent_get_local_candidates:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = ""]
    #[doc = " Retrieve from the agent the list of all local candidates"]
    #[doc = " for a stream's component"]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "The caller owns the returned GSList as well as the candidates contained"]
    #[doc = "within it."]
    #[doc = "To get full results, the client should wait for the"]
    #[doc = "#NiceAgent::candidate-gathering-done signal."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Returns: (element-type NiceCandidate) (transfer full): a #GSList of"]
    #[doc = " #NiceCandidate objects representing the local candidates of @agent"]
    pub fn nice_agent_get_local_candidates(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> *mut GSList;
}
extern "C" {
    #[doc = " nice_agent_get_remote_candidates:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = ""]
    #[doc = " Get a list of the remote candidates set on a stream's component"]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "The caller owns the returned GSList as well as the candidates contained"]
    #[doc = "within it."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "The list of remote candidates can change during processing."]
    #[doc = "The client should register for the #NiceAgent::new-remote-candidate signal"]
    #[doc = "to get notified of new remote candidates."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Returns: (element-type NiceCandidate) (transfer full): a #GSList of"]
    #[doc = " #NiceCandidates objects representing the remote candidates set on the @agent"]
    pub fn nice_agent_get_remote_candidates(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> *mut GSList;
}
extern "C" {
    #[doc = " nice_agent_restart:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = ""]
    #[doc = " Restarts the session as defined in ICE draft 19. This function"]
    #[doc = " needs to be called both when initiating (ICE spec section 9.1.1.1."]
    #[doc = " \"ICE Restarts\"), as well as when reacting (spec section 9.2.1.1."]
    #[doc = " \"Detecting ICE Restart\") to a restart."]
    #[doc = ""]
    #[doc = " Returns: %TRUE on success %FALSE on error"]
    pub fn nice_agent_restart(agent: *mut NiceAgent) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_restart_stream:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = ""]
    #[doc = " Restarts a single stream as defined in RFC 5245. This function"]
    #[doc = " needs to be called both when initiating (ICE spec section 9.1.1.1."]
    #[doc = " \"ICE Restarts\"), as well as when reacting (spec section 9.2.1.1."]
    #[doc = " \"Detecting ICE Restart\") to a restart."]
    #[doc = ""]
    #[doc = " Unlike nice_agent_restart(), this applies to a single stream. It also"]
    #[doc = " does not generate a new tie breaker."]
    #[doc = ""]
    #[doc = " Returns: %TRUE on success %FALSE on error"]
    #[doc = ""]
    #[doc = " Since: 0.1.6"]
    pub fn nice_agent_restart_stream(agent: *mut NiceAgent, stream_id: guint) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_attach_recv: (skip)"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = " @ctx: The Glib Mainloop Context to use for listening on the component"]
    #[doc = " @func: The callback function to be called when data is received on"]
    #[doc = " the stream's component (will not be called for STUN messages that"]
    #[doc = " should be handled by #NiceAgent itself)"]
    #[doc = " @data: user data associated with the callback"]
    #[doc = ""]
    #[doc = " Attaches the stream's component's sockets to the Glib Mainloop Context in"]
    #[doc = " order to be notified whenever data becomes available for a component,"]
    #[doc = " and to enable #NiceAgent to receive STUN messages (during the"]
    #[doc = " establishment of ICE connectivity)."]
    #[doc = ""]
    #[doc = " This must not be used in combination with nice_agent_recv_messages() (or"]
    #[doc = " #NiceIOStream or #NiceInputStream) on the same stream/component pair."]
    #[doc = ""]
    #[doc = " Calling nice_agent_attach_recv() with a %NULL @func will detach any existing"]
    #[doc = " callback and cause reception to be paused for the given stream/component"]
    #[doc = " pair. You must iterate the previously specified #GMainContext sufficiently to"]
    #[doc = " ensure all pending I/O callbacks have been received before calling this"]
    #[doc = " function to unset @func, otherwise data loss of received packets may occur."]
    #[doc = ""]
    #[doc = " Returns: %TRUE on success, %FALSE if the stream or component IDs are invalid."]
    pub fn nice_agent_attach_recv(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        ctx: *mut GMainContext,
        func: NiceAgentRecvFunc,
        data: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_recv:"]
    #[doc = " @agent: a #NiceAgent"]
    #[doc = " @stream_id: the ID of the stream to receive on"]
    #[doc = " @component_id: the ID of the component to receive on"]
    #[doc = " @buf: (array length=buf_len) (out caller-allocates): caller-allocated buffer"]
    #[doc = " to write the received data into, of length at least @buf_len"]
    #[doc = " @buf_len: length of @buf"]
    #[doc = " @cancellable: (allow-none): a #GCancellable to allow the operation to be"]
    #[doc = " cancelled from another thread, or %NULL"]
    #[doc = " @error: (allow-none): return location for a #GError, or %NULL"]
    #[doc = ""]
    #[doc = " A single-message version of nice_agent_recv_messages()."]
    #[doc = ""]
    #[doc = " Returns: the number of bytes written to @buf on success (guaranteed to be"]
    #[doc = " greater than 0 unless @buf_len is 0), 0 if in reliable mode and the remote"]
    #[doc = " peer closed the stream, or -1 on error"]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn nice_agent_recv(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        buf: *mut guint8,
        buf_len: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[doc = " nice_agent_recv_messages:"]
    #[doc = " @agent: a #NiceAgent"]
    #[doc = " @stream_id: the ID of the stream to receive on"]
    #[doc = " @component_id: the ID of the component to receive on"]
    #[doc = " @messages: (array length=n_messages) (out caller-allocates): caller-allocated"]
    #[doc = " array of #NiceInputMessages to write the received messages into, of length at"]
    #[doc = " least @n_messages"]
    #[doc = " @n_messages: number of entries in @messages"]
    #[doc = " @cancellable: (allow-none): a #GCancellable to allow the operation to be"]
    #[doc = " cancelled from another thread, or %NULL"]
    #[doc = " @error: (allow-none): return location for a #GError, or %NULL"]
    #[doc = ""]
    #[doc = " Block on receiving data from the given stream/component combination on"]
    #[doc = " @agent, returning only once exactly @n_messages messages have been received"]
    #[doc = " and written into @messages, the stream is closed by the other end or by"]
    #[doc = " calling nice_agent_remove_stream(), or @cancellable is cancelled."]
    #[doc = ""]
    #[doc = " Any STUN packets received will not be added to @messages; instead,"]
    #[doc = " they'll be passed for processing to #NiceAgent itself. Since #NiceAgent"]
    #[doc = " does not poll for messages on its own, it's therefore essential to keep"]
    #[doc = " calling this function for ICE connection establishment to work."]
    #[doc = ""]
    #[doc = " In the non-error case, in reliable mode, this will block until all buffers in"]
    #[doc = " all @n_messages have been filled with received data (i.e. @messages is"]
    #[doc = " treated as a large, flat array of buffers). In non-reliable mode, it will"]
    #[doc = " block until @n_messages messages have been received, each of which does not"]
    #[doc = " have to fill all the buffers in its #NiceInputMessage. In the non-reliable"]
    #[doc = " case, each #NiceInputMessage must have enough buffers to contain an entire"]
    #[doc = " message (65536 bytes), or any excess data may be silently dropped."]
    #[doc = ""]
    #[doc = " For each received message, #NiceInputMessage::length will be set to the"]
    #[doc = " number of valid bytes stored in the messages buffers. The bytes are stored"]
    #[doc = " sequentially in the buffers; there are no gaps apart from at the end of the"]
    #[doc = " buffer array (in non-reliable mode). If non-%NULL on input,"]
    #[doc = " #NiceInputMessage::from will have the address of the sending peer stored in"]
    #[doc = " it. The base addresses, sizes, and number of buffers in each message will not"]
    #[doc = " be modified in any case."]
    #[doc = ""]
    #[doc = " This must not be used in combination with nice_agent_attach_recv() on the"]
    #[doc = " same stream/component pair."]
    #[doc = ""]
    #[doc = " If the stream/component pair doesnt exist, or if a suitable candidate socket"]
    #[doc = " hasnt yet been selected for it, a %G_IO_ERROR_BROKEN_PIPE error will be"]
    #[doc = " returned. A %G_IO_ERROR_CANCELLED error will be returned if the operation was"]
    #[doc = " cancelled. %G_IO_ERROR_FAILED will be returned for other errors."]
    #[doc = ""]
    #[doc = " Returns: the number of valid messages written to @messages on success"]
    #[doc = " (guaranteed to be greater than 0 unless @n_messages is 0), 0 if the remote"]
    #[doc = " peer closed the stream, or -1 on error"]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn nice_agent_recv_messages(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        messages: *mut NiceInputMessage,
        n_messages: guint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    #[doc = " nice_agent_recv_nonblocking:"]
    #[doc = " @agent: a #NiceAgent"]
    #[doc = " @stream_id: the ID of the stream to receive on"]
    #[doc = " @component_id: the ID of the component to receive on"]
    #[doc = " @buf: (array length=buf_len) (out caller-allocates): caller-allocated buffer"]
    #[doc = " to write the received data into, of length at least @buf_len"]
    #[doc = " @buf_len: length of @buf"]
    #[doc = " @cancellable: (allow-none): a #GCancellable to allow the operation to be"]
    #[doc = " cancelled from another thread, or %NULL"]
    #[doc = " @error: (allow-none): return location for a #GError, or %NULL"]
    #[doc = ""]
    #[doc = " A single-message version of nice_agent_recv_messages_nonblocking()."]
    #[doc = ""]
    #[doc = " Returns: the number of bytes received into @buf on success (guaranteed to be"]
    #[doc = " greater than 0 unless @buf_len is 0), 0 if in reliable mode and the remote"]
    #[doc = " peer closed the stream, or -1 on error"]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn nice_agent_recv_nonblocking(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        buf: *mut guint8,
        buf_len: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[doc = " nice_agent_recv_messages_nonblocking:"]
    #[doc = " @agent: a #NiceAgent"]
    #[doc = " @stream_id: the ID of the stream to receive on"]
    #[doc = " @component_id: the ID of the component to receive on"]
    #[doc = " @messages: (array length=n_messages) (out caller-allocates): caller-allocated"]
    #[doc = " array of #NiceInputMessages to write the received messages into, of length at"]
    #[doc = " least @n_messages"]
    #[doc = " @n_messages: number of entries in @messages"]
    #[doc = " @cancellable: (allow-none): a #GCancellable to allow the operation to be"]
    #[doc = " cancelled from another thread, or %NULL"]
    #[doc = " @error: (allow-none): return location for a #GError, or %NULL"]
    #[doc = ""]
    #[doc = " Try to receive data from the given stream/component combination on @agent,"]
    #[doc = " without blocking. If receiving data would block, -1 is returned and"]
    #[doc = " %G_IO_ERROR_WOULD_BLOCK is set in @error. If any other error occurs, -1 is"]
    #[doc = " returned and @error is set accordingly. Otherwise, 0 is returned if (and only"]
    #[doc = " if) @n_messages is 0. In all other cases, the number of valid messages stored"]
    #[doc = " in @messages is returned, and will be greater than 0."]
    #[doc = ""]
    #[doc = " This function behaves similarly to nice_agent_recv_messages(), except that it"]
    #[doc = " will not block on filling (in reliable mode) or receiving (in non-reliable"]
    #[doc = " mode) exactly @n_messages messages. In reliable mode, it will receive bytes"]
    #[doc = " into @messages until it would block; in non-reliable mode, it will receive"]
    #[doc = " messages until it would block."]
    #[doc = ""]
    #[doc = " Any STUN packets received will not be added to @messages; instead,"]
    #[doc = " they'll be passed for processing to #NiceAgent itself. Since #NiceAgent"]
    #[doc = " does not poll for messages on its own, it's therefore essential to keep"]
    #[doc = " calling this function for ICE connection establishment to work."]
    #[doc = ""]
    #[doc = " As this function is non-blocking, @cancellable is included only for parity"]
    #[doc = " with nice_agent_recv_messages(). If @cancellable is cancelled before this"]
    #[doc = " function is called, a %G_IO_ERROR_CANCELLED error will be returned"]
    #[doc = " immediately."]
    #[doc = ""]
    #[doc = " This must not be used in combination with nice_agent_attach_recv() on the"]
    #[doc = " same stream/component pair."]
    #[doc = ""]
    #[doc = " Returns: the number of valid messages written to @messages on success"]
    #[doc = " (guaranteed to be greater than 0 unless @n_messages is 0), 0 if in reliable"]
    #[doc = " mode and the remote peer closed the stream, or -1 on error"]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn nice_agent_recv_messages_nonblocking(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        messages: *mut NiceInputMessage,
        n_messages: guint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    #[doc = " nice_agent_set_selected_pair:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = " @lfoundation: The local foundation of the candidate to use"]
    #[doc = " @rfoundation: The remote foundation of the candidate to use"]
    #[doc = ""]
    #[doc = " Sets the selected candidate pair for media transmission"]
    #[doc = " for a given stream's component. Calling this function will"]
    #[doc = " disable all further ICE processing (connection check,"]
    #[doc = " state machine updates, etc). Note that keepalives will"]
    #[doc = " continue to be sent."]
    #[doc = ""]
    #[doc = " Returns: %TRUE on success, %FALSE if the candidate pair cannot be found"]
    pub fn nice_agent_set_selected_pair(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        lfoundation: *const gchar,
        rfoundation: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_get_selected_pair:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = " @local: The local selected candidate"]
    #[doc = " @remote: The remote selected candidate"]
    #[doc = ""]
    #[doc = " Retreive the selected candidate pair for media transmission"]
    #[doc = " for a given stream's component."]
    #[doc = ""]
    #[doc = " Returns: %TRUE on success, %FALSE if there is no selected candidate pair"]
    pub fn nice_agent_get_selected_pair(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        local: *mut *mut NiceCandidate,
        remote: *mut *mut NiceCandidate,
    ) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_get_selected_socket:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = ""]
    #[doc = " Retreive the local socket associated with the selected candidate pair"]
    #[doc = " for media transmission for a given stream's component."]
    #[doc = ""]
    #[doc = " This is useful for adding ICE support to legacy applications that already"]
    #[doc = " have a protocol that maintains a connection. If the socket is duplicated"]
    #[doc = " before unrefing the agent, the application can take over and continue to use"]
    #[doc = " it. New applications are encouraged to use the built in libnice stream"]
    #[doc = " handling instead and let libnice handle the connection maintenance."]
    #[doc = ""]
    #[doc = " Users of this method are encouraged to not use a TURN relay or any kind"]
    #[doc = " of proxy, as in this case, the socket will not be available to the"]
    #[doc = " application because the packets are encapsulated."]
    #[doc = ""]
    #[doc = " Returns: (transfer full) (nullable): pointer to the #GSocket, or %NULL if"]
    #[doc = " there is no selected candidate or if the selected candidate is a relayed"]
    #[doc = " candidate."]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn nice_agent_get_selected_socket(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> *mut GSocket;
}
extern "C" {
    #[doc = " nice_agent_set_selected_remote_candidate:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = " @candidate: The #NiceCandidate to select"]
    #[doc = ""]
    #[doc = " Sets the selected remote candidate for media transmission"]
    #[doc = " for a given stream's component. This is used to force the selection of"]
    #[doc = " a specific remote candidate even when connectivity checks are failing"]
    #[doc = " (e.g. non-ICE compatible candidates)."]
    #[doc = " Calling this function will disable all further ICE processing"]
    #[doc = " (connection check, state machine updates, etc). Note that keepalives will"]
    #[doc = " continue to be sent."]
    #[doc = ""]
    #[doc = " Returns: %TRUE on success, %FALSE on failure"]
    pub fn nice_agent_set_selected_remote_candidate(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        candidate: *mut NiceCandidate,
    ) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_set_stream_tos:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @tos: The ToS to set"]
    #[doc = ""]
    #[doc = " Sets the IP_TOS and/or IPV6_TCLASS field on the stream's sockets' options"]
    #[doc = ""]
    #[doc = " Since: 0.0.9"]
    pub fn nice_agent_set_stream_tos(agent: *mut NiceAgent, stream_id: guint, tos: gint);
}
extern "C" {
    #[doc = " nice_agent_set_software:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @software: The value of the SOFTWARE attribute to add."]
    #[doc = ""]
    #[doc = " This function will set the value of the SOFTWARE attribute to be added to"]
    #[doc = " STUN requests, responses and error responses sent during connectivity checks."]
    #[doc = " <para>"]
    #[doc = " The SOFTWARE attribute will only be added in the #NICE_COMPATIBILITY_RFC5245"]
    #[doc = " and #NICE_COMPATIBILITY_WLM2009 compatibility modes."]
    #[doc = ""]
    #[doc = " </para>"]
    #[doc = " <note>"]
    #[doc = "<para>"]
    #[doc = "The @software argument will be appended with the libnice version before"]
    #[doc = "being sent."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "The @software argument must be in UTF-8 encoding and only the first"]
    #[doc = "128 characters will be sent."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Since: 0.0.10"]
    #[doc = ""]
    pub fn nice_agent_set_software(agent: *mut NiceAgent, software: *const gchar);
}
extern "C" {
    #[doc = " nice_agent_set_stream_name:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream to change"]
    #[doc = " @name: The new name of the stream or %NULL"]
    #[doc = ""]
    #[doc = " This function will assign a media type to a stream. The only values"]
    #[doc = " that can be used to produce a valid SDP are: \"audio\", \"video\","]
    #[doc = " \"text\", \"application\", \"image\" and \"message\"."]
    #[doc = ""]
    #[doc = " This is only useful when parsing and generating an SDP of the"]
    #[doc = " candidates."]
    #[doc = ""]
    #[doc = " <para>See also: nice_agent_generate_local_sdp()</para>"]
    #[doc = " <para>See also: nice_agent_parse_remote_sdp()</para>"]
    #[doc = " <para>See also: nice_agent_get_stream_name()</para>"]
    #[doc = ""]
    #[doc = " Returns: %TRUE if the name has been set. %FALSE in case of error"]
    #[doc = " (invalid stream or duplicate name)."]
    #[doc = " Since: 0.1.4"]
    pub fn nice_agent_set_stream_name(
        agent: *mut NiceAgent,
        stream_id: guint,
        name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_get_stream_name:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream to change"]
    #[doc = ""]
    #[doc = " This function will return the name assigned to a stream."]
    #[doc = ""]
    #[doc = " <para>See also: nice_agent_set_stream_name()</para>"]
    #[doc = ""]
    #[doc = " Returns: The name of the stream. The name is only valid while the stream"]
    #[doc = " exists or until it changes through a call to nice_agent_set_stream_name()."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Since: 0.1.4"]
    pub fn nice_agent_get_stream_name(agent: *mut NiceAgent, stream_id: guint) -> *const gchar;
}
extern "C" {
    #[doc = " nice_agent_get_default_local_candidate:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = ""]
    #[doc = " This helper function will return the recommended default candidate to be"]
    #[doc = " used for non-ICE compatible clients. This will usually be the candidate"]
    #[doc = " with the lowest priority, since it will be the longest path but the one with"]
    #[doc = " the most chances of success."]
    #[doc = " <note>"]
    #[doc = "<para>"]
    #[doc = "This function is only useful in order to manually generate the"]
    #[doc = "local SDP"]
    #[doc = "</para>"]
    #[doc = " </note>"]
    #[doc = ""]
    #[doc = " Returns: The candidate to be used as the default candidate, or %NULL in case"]
    #[doc = " of error. Must be freed with nice_candidate_free() once done."]
    #[doc = ""]
    pub fn nice_agent_get_default_local_candidate(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> *mut NiceCandidate;
}
extern "C" {
    #[doc = " nice_agent_generate_local_sdp:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = ""]
    #[doc = " Generate an SDP string containing the local candidates and credentials for"]
    #[doc = " all streams and components in the agent."]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "The SDP will not contain any codec lines and the 'm' line will not list"]
    #[doc = "any payload types."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "It is highly recommended to set names on the streams prior to calling this"]
    #[doc = "function. Unnamed streams will show up as '-' in the 'm' line, but the SDP"]
    #[doc = "will not be parseable with nice_agent_parse_remote_sdp() if a stream is"]
    #[doc = "unnamed."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "The default candidate in the SDP will be selected based on the lowest"]
    #[doc = "priority candidate for the first component."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " <para>See also: nice_agent_set_stream_name() </para>"]
    #[doc = " <para>See also: nice_agent_parse_remote_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_generate_local_stream_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_generate_local_candidate_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_get_default_local_candidate() </para>"]
    #[doc = ""]
    #[doc = " Returns: A string representing the local SDP. Must be freed with g_free()"]
    #[doc = " once done."]
    #[doc = ""]
    #[doc = " Since: 0.1.4"]
    pub fn nice_agent_generate_local_sdp(agent: *mut NiceAgent) -> *mut gchar;
}
extern "C" {
    #[doc = " nice_agent_generate_local_stream_sdp:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @include_non_ice: Whether or not to include non ICE specific lines"]
    #[doc = " (m=, c= and a=rtcp: lines)"]
    #[doc = ""]
    #[doc = " Generate an SDP string containing the local candidates and credentials"]
    #[doc = " for a stream."]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "The SDP will not contain any codec lines and the 'm' line will not list"]
    #[doc = "any payload types."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "It is highly recommended to set the name of the stream prior to calling this"]
    #[doc = "function. Unnamed streams will show up as '-' in the 'm' line."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "The default candidate in the SDP will be selected based on the lowest"]
    #[doc = "priority candidate."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " <para>See also: nice_agent_set_stream_name() </para>"]
    #[doc = " <para>See also: nice_agent_parse_remote_stream_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_generate_local_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_generate_local_candidate_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_get_default_local_candidate() </para>"]
    #[doc = ""]
    #[doc = " Returns: A string representing the local SDP for the stream. Must be freed"]
    #[doc = " with g_free() once done."]
    #[doc = ""]
    #[doc = " Since: 0.1.4"]
    pub fn nice_agent_generate_local_stream_sdp(
        agent: *mut NiceAgent,
        stream_id: guint,
        include_non_ice: gboolean,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " nice_agent_generate_local_candidate_sdp:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @candidate: The candidate to generate"]
    #[doc = ""]
    #[doc = " Generate an SDP string representing a local candidate."]
    #[doc = ""]
    #[doc = " <para>See also: nice_agent_parse_remote_candidate_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_generate_local_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_generate_local_stream_sdp() </para>"]
    #[doc = ""]
    #[doc = " Returns: A string representing the SDP for the candidate. Must be freed"]
    #[doc = " with g_free() once done."]
    #[doc = ""]
    #[doc = " Since: 0.1.4"]
    pub fn nice_agent_generate_local_candidate_sdp(
        agent: *mut NiceAgent,
        candidate: *mut NiceCandidate,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " nice_agent_parse_remote_sdp:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @sdp: The remote SDP to parse"]
    #[doc = ""]
    #[doc = " Parse an SDP string and extracts candidates and credentials from it and sets"]
    #[doc = " them on the agent."]
    #[doc = ""]
    #[doc = " <para>See also: nice_agent_set_stream_name() </para>"]
    #[doc = " <para>See also: nice_agent_generate_local_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_parse_remote_stream_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_parse_remote_candidate_sdp() </para>"]
    #[doc = ""]
    #[doc = " Returns: The number of candidates added, negative on errors"]
    #[doc = ""]
    #[doc = " Since: 0.1.4"]
    pub fn nice_agent_parse_remote_sdp(
        agent: *mut NiceAgent,
        sdp: *const gchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " nice_agent_parse_remote_stream_sdp:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream to parse"]
    #[doc = " @sdp: The remote SDP to parse"]
    #[doc = " @ufrag: Pointer to store the ice ufrag if non %NULL. Must be freed with"]
    #[doc = " g_free() after use"]
    #[doc = " @pwd: Pointer to store the ice password if non %NULL. Must be freed with"]
    #[doc = " g_free() after use"]
    #[doc = ""]
    #[doc = " Parse an SDP string representing a single stream and extracts candidates"]
    #[doc = " and credentials from it."]
    #[doc = ""]
    #[doc = " <para>See also: nice_agent_generate_local_stream_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_parse_remote_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_parse_remote_candidate_sdp() </para>"]
    #[doc = ""]
    #[doc = " Returns: (element-type NiceCandidate) (transfer full): A #GSList of"]
    #[doc = " candidates parsed from the SDP, or %NULL in case of errors"]
    #[doc = ""]
    #[doc = " Since: 0.1.4"]
    pub fn nice_agent_parse_remote_stream_sdp(
        agent: *mut NiceAgent,
        stream_id: guint,
        sdp: *const gchar,
        ufrag: *mut *mut gchar,
        pwd: *mut *mut gchar,
    ) -> *mut GSList;
}
extern "C" {
    #[doc = " nice_agent_parse_remote_candidate_sdp:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream the candidate belongs to"]
    #[doc = " @sdp: The remote SDP to parse"]
    #[doc = ""]
    #[doc = " Parse an SDP string and extracts the candidate from it."]
    #[doc = ""]
    #[doc = " <para>See also: nice_agent_generate_local_candidate_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_parse_remote_sdp() </para>"]
    #[doc = " <para>See also: nice_agent_parse_remote_stream_sdp() </para>"]
    #[doc = ""]
    #[doc = " Returns: The parsed candidate or %NULL if there was an error."]
    #[doc = ""]
    #[doc = " Since: 0.1.4"]
    pub fn nice_agent_parse_remote_candidate_sdp(
        agent: *mut NiceAgent,
        stream_id: guint,
        sdp: *const gchar,
    ) -> *mut NiceCandidate;
}
extern "C" {
    #[doc = " nice_agent_get_io_stream:"]
    #[doc = " @agent: A #NiceAgent"]
    #[doc = " @stream_id: The ID of the stream to wrap"]
    #[doc = " @component_id: The ID of the component to wrap"]
    #[doc = ""]
    #[doc = " Gets a #GIOStream wrapper around the given stream and component in"]
    #[doc = " @agent. The I/O stream will be valid for as long as @stream_id is valid."]
    #[doc = " The #GInputStream and #GOutputStream implement #GPollableInputStream and"]
    #[doc = " #GPollableOutputStream."]
    #[doc = ""]
    #[doc = " This function may only be called on reliable #NiceAgents. It is a"]
    #[doc = " programming error to try and create an I/O stream wrapper for an"]
    #[doc = " unreliable stream."]
    #[doc = ""]
    #[doc = " Returns: (transfer full): A #GIOStream."]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn nice_agent_get_io_stream(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> *mut GIOStream;
}
extern "C" {
    #[doc = " nice_component_state_to_string:"]
    #[doc = " @state: a #NiceComponentState"]
    #[doc = ""]
    #[doc = " Returns a string representation of the state, generally to use in debug"]
    #[doc = " messages."]
    #[doc = ""]
    #[doc = " Returns: (transfer none): a string representation of @state"]
    #[doc = " Since: 0.1.6"]
    pub fn nice_component_state_to_string(state: NiceComponentState) -> *const gchar;
}
extern "C" {
    #[doc = " nice_agent_forget_relays:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = ""]
    #[doc = " Forget all the relay servers previously added using"]
    #[doc = " nice_agent_set_relay_info(). Currently connected streams will keep"]
    #[doc = " using the relay as long as they have not been restarted and haven't"]
    #[doc = " succesfully negotiated a different path."]
    #[doc = ""]
    #[doc = " Returns: %FALSE if the component could not be found, %TRUE otherwise"]
    #[doc = ""]
    #[doc = " Since: 0.1.6"]
    pub fn nice_agent_forget_relays(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_get_component_state:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = ""]
    #[doc = " Retrieves the current state of a component."]
    #[doc = ""]
    #[doc = " Returns: the #NiceComponentState of the component and"]
    #[doc = " %NICE_COMPONENT_STATE_FAILED if the component was invalid."]
    #[doc = ""]
    #[doc = " Since: 0.1.8"]
    pub fn nice_agent_get_component_state(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> NiceComponentState;
}
extern "C" {
    #[doc = " nice_agent_peer_candidate_gathering_done:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = ""]
    #[doc = " Notifies the agent that the remote peer has concluded candidate gathering and"]
    #[doc = " thus no more remote candidates are expected to arrive for @stream_id."]
    #[doc = ""]
    #[doc = " This will allow the stream components without a successful connectivity check"]
    #[doc = " to stop waiting for more candidates to come and finally transit into"]
    #[doc = " %NICE_COMPONENT_STATE_FAILED."]
    #[doc = ""]
    #[doc = " Calling the function has an effect only when #NiceAgent:trickle-ice is %TRUE."]
    #[doc = ""]
    #[doc = " Returns: %FALSE if the stream could not be found, %TRUE otherwise"]
    #[doc = ""]
    #[doc = " Since: 0.1.16"]
    pub fn nice_agent_peer_candidate_gathering_done(
        agent: *mut NiceAgent,
        stream_id: guint,
    ) -> gboolean;
}
extern "C" {
    #[doc = " nice_agent_close_async:"]
    #[doc = " @agent: The #NiceAgent object"]
    #[doc = " @callback: (nullable): A callback that will be called when the closing is"]
    #[doc = "  complete"]
    #[doc = " @callback_data: (nullable): A pointer that will be passed to the callback"]
    #[doc = ""]
    #[doc = " Asynchronously closes resources the agent has allocated on remote servers."]
    #[doc = ""]
    #[doc = " The agent will call the callback in the current #GMainContext in"]
    #[doc = " which this function is called. The #GAsyncResult in the callback"]
    #[doc = " can be ignored as this operation never fails."]
    #[doc = ""]
    #[doc = " Calling this function before freeing the agent makes sure the allocated relay"]
    #[doc = " ports aren't left behind on TURN server but properly removed."]
    #[doc = ""]
    #[doc = " Since: 0.1.16"]
    pub fn nice_agent_close_async(
        agent: *mut NiceAgent,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
    );
}
extern "C" {
    #[doc = " nice_agent_get_sockets:"]
    #[doc = " @agent: The #NiceAgent Object"]
    #[doc = " @stream_id: The ID of the stream"]
    #[doc = " @component_id: The ID of the component"]
    #[doc = ""]
    #[doc = " Each component can have multiple sockets, this is an API to retrieve them all"]
    #[doc = " to be able to set properties. Most of the sockets for a component are created when"]
    #[doc = " calling nice_agent_gather_candidates(), so this API should be called right after to"]
    #[doc = " able to set properties on the sockets before they are used."]
    #[doc = ""]
    #[doc = " These sockets can be a mix of UDP & TCP sockets depending on the compatibility mode"]
    #[doc = " and options that have been set."]
    #[doc = ""]
    #[doc = " Returns: (element-type GSocket) (transfer full): An array"]
    #[doc = " containing all of the sockets for this component. Free with"]
    #[doc = " g_ptr_array_unref() when done."]
    #[doc = ""]
    #[doc = " Since: 0.1.17"]
    pub fn nice_agent_get_sockets(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> *mut GPtrArray;
}
extern "C" {
    #[doc = " nice_interfaces_get_ip_for_interface:"]
    #[doc = " @interface_name: name of local interface"]
    #[doc = ""]
    #[doc = " Retrieves the IP address of an interface by its name. If this fails, %NULL"]
    #[doc = " is returned."]
    #[doc = ""]
    #[doc = " Returns: (nullable) (transfer full): a newly-allocated string with the IP"]
    #[doc = " address"]
    pub fn nice_interfaces_get_ip_for_interface(interface_name: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[doc = " nice_interfaces_get_local_ips:"]
    #[doc = " @include_loopback: Include any loopback devices"]
    #[doc = ""]
    #[doc = " Get a list of local ipv4 interface addresses"]
    #[doc = ""]
    #[doc = " Returns: (element-type utf8) (transfer full): a newly-allocated #GList of"]
    #[doc = " strings. The caller must free it."]
    pub fn nice_interfaces_get_local_ips(include_loopback: gboolean) -> *mut GList;
}
extern "C" {
    #[doc = " nice_interfaces_get_local_interfaces:"]
    #[doc = ""]
    #[doc = " Get the list of local interfaces"]
    #[doc = ""]
    #[doc = " Returns: (element-type utf8) (transfer full): a newly-allocated #GList of"]
    #[doc = " strings. The caller must free it."]
    pub fn nice_interfaces_get_local_interfaces() -> *mut GList;
}
#[doc = " StunAgent:"]
#[doc = ""]
#[doc = " An opaque structure representing the STUN agent."]
pub type StunAgent = stun_agent_t;
pub type StunMessage = _StunMessage;
pub const StunClass_STUN_REQUEST: StunClass = 0;
pub const StunClass_STUN_INDICATION: StunClass = 1;
pub const StunClass_STUN_RESPONSE: StunClass = 2;
pub const StunClass_STUN_ERROR: StunClass = 3;
#[doc = " StunClass:"]
#[doc = " @STUN_REQUEST: A STUN Request message"]
#[doc = " @STUN_INDICATION: A STUN indication message"]
#[doc = " @STUN_RESPONSE: A STUN Response message"]
#[doc = " @STUN_ERROR: A STUN Error message"]
#[doc = ""]
#[doc = " This enum is used to represent the class of"]
#[doc = " a STUN message, as defined in RFC5389"]
pub type StunClass = i32;
pub const StunMethod_STUN_BINDING: StunMethod = 1;
pub const StunMethod_STUN_SHARED_SECRET: StunMethod = 2;
pub const StunMethod_STUN_ALLOCATE: StunMethod = 3;
pub const StunMethod_STUN_SET_ACTIVE_DST: StunMethod = 4;
pub const StunMethod_STUN_REFRESH: StunMethod = 4;
pub const StunMethod_STUN_SEND: StunMethod = 4;
pub const StunMethod_STUN_CONNECT: StunMethod = 5;
pub const StunMethod_STUN_OLD_SET_ACTIVE_DST: StunMethod = 6;
pub const StunMethod_STUN_IND_SEND: StunMethod = 6;
pub const StunMethod_STUN_IND_DATA: StunMethod = 7;
pub const StunMethod_STUN_IND_CONNECT_STATUS: StunMethod = 8;
pub const StunMethod_STUN_CREATEPERMISSION: StunMethod = 8;
pub const StunMethod_STUN_CHANNELBIND: StunMethod = 9;
#[doc = " StunMethod:"]
#[doc = " @STUN_BINDING: The Binding method as defined by the RFC5389"]
#[doc = " @STUN_SHARED_SECRET: The Shared-Secret method as defined by the RFC3489"]
#[doc = " @STUN_ALLOCATE: The Allocate method as defined by the TURN draft 12"]
#[doc = " @STUN_SET_ACTIVE_DST: The Set-Active-Destination method as defined by"]
#[doc = " the TURN draft 4"]
#[doc = " @STUN_REFRESH: The Refresh method as defined by the TURN draft 12"]
#[doc = " @STUN_SEND: The Send method as defined by the TURN draft 00"]
#[doc = " @STUN_CONNECT: The Connect method as defined by the TURN draft 4"]
#[doc = " @STUN_OLD_SET_ACTIVE_DST: The older Set-Active-Destination method as"]
#[doc = " defined by the TURN draft 0"]
#[doc = " @STUN_IND_SEND: The Send method used in indication messages as defined"]
#[doc = " by the TURN draft 12"]
#[doc = " @STUN_IND_DATA: The Data method used in indication messages as defined"]
#[doc = " by the TURN draft 12"]
#[doc = " @STUN_IND_CONNECT_STATUS:  The Connect-Status method used in indication"]
#[doc = " messages as defined by the TURN draft 4"]
#[doc = " @STUN_CREATEPERMISSION: The CreatePermission method as defined by"]
#[doc = " the TURN draft 12"]
#[doc = " @STUN_CHANNELBIND: The ChannelBind method as defined by the TURN draft 12"]
#[doc = ""]
#[doc = " This enum is used to represent the method of"]
#[doc = " a STUN message, as defined by various RFCs"]
pub type StunMethod = i32;
pub const StunAttribute_STUN_ATTRIBUTE_MAPPED_ADDRESS: StunAttribute = 1;
pub const StunAttribute_STUN_ATTRIBUTE_RESPONSE_ADDRESS: StunAttribute = 2;
pub const StunAttribute_STUN_ATTRIBUTE_CHANGE_REQUEST: StunAttribute = 3;
pub const StunAttribute_STUN_ATTRIBUTE_SOURCE_ADDRESS: StunAttribute = 4;
pub const StunAttribute_STUN_ATTRIBUTE_CHANGED_ADDRESS: StunAttribute = 5;
pub const StunAttribute_STUN_ATTRIBUTE_USERNAME: StunAttribute = 6;
pub const StunAttribute_STUN_ATTRIBUTE_PASSWORD: StunAttribute = 7;
pub const StunAttribute_STUN_ATTRIBUTE_MESSAGE_INTEGRITY: StunAttribute = 8;
pub const StunAttribute_STUN_ATTRIBUTE_ERROR_CODE: StunAttribute = 9;
pub const StunAttribute_STUN_ATTRIBUTE_UNKNOWN_ATTRIBUTES: StunAttribute = 10;
pub const StunAttribute_STUN_ATTRIBUTE_REFLECTED_FROM: StunAttribute = 11;
pub const StunAttribute_STUN_ATTRIBUTE_CHANNEL_NUMBER: StunAttribute = 12;
pub const StunAttribute_STUN_ATTRIBUTE_LIFETIME: StunAttribute = 13;
pub const StunAttribute_STUN_ATTRIBUTE_MS_ALTERNATE_SERVER: StunAttribute = 14;
pub const StunAttribute_STUN_ATTRIBUTE_MAGIC_COOKIE: StunAttribute = 15;
pub const StunAttribute_STUN_ATTRIBUTE_BANDWIDTH: StunAttribute = 16;
pub const StunAttribute_STUN_ATTRIBUTE_DESTINATION_ADDRESS: StunAttribute = 17;
pub const StunAttribute_STUN_ATTRIBUTE_REMOTE_ADDRESS: StunAttribute = 18;
pub const StunAttribute_STUN_ATTRIBUTE_PEER_ADDRESS: StunAttribute = 18;
pub const StunAttribute_STUN_ATTRIBUTE_XOR_PEER_ADDRESS: StunAttribute = 18;
pub const StunAttribute_STUN_ATTRIBUTE_DATA: StunAttribute = 19;
pub const StunAttribute_STUN_ATTRIBUTE_REALM: StunAttribute = 20;
pub const StunAttribute_STUN_ATTRIBUTE_NONCE: StunAttribute = 21;
pub const StunAttribute_STUN_ATTRIBUTE_RELAY_ADDRESS: StunAttribute = 22;
pub const StunAttribute_STUN_ATTRIBUTE_RELAYED_ADDRESS: StunAttribute = 22;
pub const StunAttribute_STUN_ATTRIBUTE_XOR_RELAYED_ADDRESS: StunAttribute = 22;
pub const StunAttribute_STUN_ATTRIBUTE_REQUESTED_ADDRESS_TYPE: StunAttribute = 23;
pub const StunAttribute_STUN_ATTRIBUTE_REQUESTED_PORT_PROPS: StunAttribute = 24;
pub const StunAttribute_STUN_ATTRIBUTE_REQUESTED_PROPS: StunAttribute = 24;
pub const StunAttribute_STUN_ATTRIBUTE_EVEN_PORT: StunAttribute = 24;
pub const StunAttribute_STUN_ATTRIBUTE_REQUESTED_TRANSPORT: StunAttribute = 25;
pub const StunAttribute_STUN_ATTRIBUTE_DONT_FRAGMENT: StunAttribute = 26;
pub const StunAttribute_STUN_ATTRIBUTE_XOR_MAPPED_ADDRESS: StunAttribute = 32;
pub const StunAttribute_STUN_ATTRIBUTE_TIMER_VAL: StunAttribute = 33;
pub const StunAttribute_STUN_ATTRIBUTE_REQUESTED_IP: StunAttribute = 34;
pub const StunAttribute_STUN_ATTRIBUTE_RESERVATION_TOKEN: StunAttribute = 34;
pub const StunAttribute_STUN_ATTRIBUTE_CONNECT_STAT: StunAttribute = 35;
pub const StunAttribute_STUN_ATTRIBUTE_PRIORITY: StunAttribute = 36;
pub const StunAttribute_STUN_ATTRIBUTE_USE_CANDIDATE: StunAttribute = 37;
pub const StunAttribute_STUN_ATTRIBUTE_OPTIONS: StunAttribute = 32769;
pub const StunAttribute_STUN_ATTRIBUTE_MS_VERSION: StunAttribute = 32776;
pub const StunAttribute_STUN_ATTRIBUTE_MS_XOR_MAPPED_ADDRESS: StunAttribute = 32800;
pub const StunAttribute_STUN_ATTRIBUTE_SOFTWARE: StunAttribute = 32802;
pub const StunAttribute_STUN_ATTRIBUTE_ALTERNATE_SERVER: StunAttribute = 32803;
pub const StunAttribute_STUN_ATTRIBUTE_FINGERPRINT: StunAttribute = 32808;
pub const StunAttribute_STUN_ATTRIBUTE_ICE_CONTROLLED: StunAttribute = 32809;
pub const StunAttribute_STUN_ATTRIBUTE_ICE_CONTROLLING: StunAttribute = 32810;
pub const StunAttribute_STUN_ATTRIBUTE_MS_SEQUENCE_NUMBER: StunAttribute = 32848;
pub const StunAttribute_STUN_ATTRIBUTE_CANDIDATE_IDENTIFIER: StunAttribute = 32852;
pub const StunAttribute_STUN_ATTRIBUTE_MS_IMPLEMENTATION_VERSION: StunAttribute = 32880;
pub const StunAttribute_STUN_ATTRIBUTE_NOMINATION: StunAttribute = 49153;
#[doc = " StunAttribute:"]
#[doc = " @STUN_ATTRIBUTE_MAPPED_ADDRESS: The MAPPED-ADDRESS attribute as defined"]
#[doc = " by RFC5389"]
#[doc = " @STUN_ATTRIBUTE_RESPONSE_ADDRESS: The RESPONSE-ADDRESS attribute as defined"]
#[doc = " by RFC3489"]
#[doc = " @STUN_ATTRIBUTE_CHANGE_REQUEST: The CHANGE-REQUEST attribute as defined by"]
#[doc = " RFC3489"]
#[doc = " @STUN_ATTRIBUTE_SOURCE_ADDRESS: The SOURCE-ADDRESS attribute as defined by"]
#[doc = " RFC3489"]
#[doc = " @STUN_ATTRIBUTE_CHANGED_ADDRESS: The CHANGED-ADDRESS attribute as defined"]
#[doc = " by RFC3489"]
#[doc = " @STUN_ATTRIBUTE_USERNAME: The USERNAME attribute as defined by RFC5389"]
#[doc = " @STUN_ATTRIBUTE_PASSWORD: The PASSWORD attribute as defined by RFC3489"]
#[doc = " @STUN_ATTRIBUTE_MESSAGE_INTEGRITY: The MESSAGE-INTEGRITY attribute as defined"]
#[doc = " by RFC5389"]
#[doc = " @STUN_ATTRIBUTE_ERROR_CODE: The ERROR-CODE attribute as defined by RFC5389"]
#[doc = " @STUN_ATTRIBUTE_UNKNOWN_ATTRIBUTES: The UNKNOWN-ATTRIBUTES attribute as"]
#[doc = " defined by RFC5389"]
#[doc = " @STUN_ATTRIBUTE_REFLECTED_FROM: The REFLECTED-FROM attribute as defined"]
#[doc = " by RFC3489"]
#[doc = " @STUN_ATTRIBUTE_CHANNEL_NUMBER: The CHANNEL-NUMBER attribute as defined by"]
#[doc = " TURN draft 09 and 12"]
#[doc = " @STUN_ATTRIBUTE_LIFETIME: The LIFETIME attribute as defined by TURN"]
#[doc = " draft 04, 09 and 12"]
#[doc = " @STUN_ATTRIBUTE_MS_ALTERNATE_SERVER: The ALTERNATE-SERVER attribute as"]
#[doc = " defined by [MS-TURN]"]
#[doc = " @STUN_ATTRIBUTE_MAGIC_COOKIE: The MAGIC-COOKIE attribute as defined by"]
#[doc = " the rosenberg-midcom TURN draft 08"]
#[doc = " @STUN_ATTRIBUTE_BANDWIDTH: The BANDWIDTH attribute as defined by TURN draft 04"]
#[doc = " @STUN_ATTRIBUTE_DESTINATION_ADDRESS: The DESTINATION-ADDRESS attribute as"]
#[doc = " defined by the rosenberg-midcom TURN draft 08"]
#[doc = " @STUN_ATTRIBUTE_REMOTE_ADDRESS: The REMOTE-ADDRESS attribute as defined by"]
#[doc = " TURN draft 04"]
#[doc = " @STUN_ATTRIBUTE_PEER_ADDRESS: The PEER-ADDRESS attribute as defined by"]
#[doc = " TURN draft 09"]
#[doc = " @STUN_ATTRIBUTE_XOR_PEER_ADDRESS: The XOR-PEER-ADDRESS attribute as defined"]
#[doc = " by TURN draft 12"]
#[doc = " @STUN_ATTRIBUTE_DATA: The DATA attribute as defined by TURN draft 04,"]
#[doc = " 09 and 12"]
#[doc = " @STUN_ATTRIBUTE_REALM: The REALM attribute as defined by RFC5389"]
#[doc = " @STUN_ATTRIBUTE_NONCE: The NONCE attribute as defined by RFC5389"]
#[doc = " @STUN_ATTRIBUTE_RELAY_ADDRESS: The RELAY-ADDRESS attribute as defined by"]
#[doc = " TURN draft 04"]
#[doc = " @STUN_ATTRIBUTE_RELAYED_ADDRESS: The RELAYED-ADDRESS attribute as defined by"]
#[doc = " TURN draft 09"]
#[doc = " @STUN_ATTRIBUTE_XOR_RELAYED_ADDRESS: The XOR-RELAYED-ADDRESS attribute as"]
#[doc = " defined by TURN draft 12"]
#[doc = " @STUN_ATTRIBUTE_REQUESTED_ADDRESS_TYPE: The REQUESTED-ADDRESS-TYPE attribute"]
#[doc = " as defined by TURN-IPV6 draft 05"]
#[doc = " @STUN_ATTRIBUTE_REQUESTED_PORT_PROPS: The REQUESTED-PORT-PROPS attribute"]
#[doc = " as defined by TURN draft 04"]
#[doc = " @STUN_ATTRIBUTE_REQUESTED_PROPS: The REQUESTED-PROPS attribute as defined"]
#[doc = " by TURN draft 09"]
#[doc = " @STUN_ATTRIBUTE_EVEN_PORT: The EVEN-PORT attribute as defined by TURN draft 12"]
#[doc = " @STUN_ATTRIBUTE_REQUESTED_TRANSPORT: The REQUESTED-TRANSPORT attribute as"]
#[doc = " defined by TURN draft 12"]
#[doc = " @STUN_ATTRIBUTE_DONT_FRAGMENT: The DONT-FRAGMENT attribute as defined"]
#[doc = " by TURN draft 12"]
#[doc = " @STUN_ATTRIBUTE_XOR_MAPPED_ADDRESS: The XOR-MAPPED-ADDRESS attribute as"]
#[doc = " defined by RFC5389"]
#[doc = " @STUN_ATTRIBUTE_TIMER_VAL: The TIMER-VAL attribute as defined by TURN draft 04"]
#[doc = " @STUN_ATTRIBUTE_REQUESTED_IP: The REQUESTED-IP attribute as defined by"]
#[doc = " TURN draft 04"]
#[doc = " @STUN_ATTRIBUTE_RESERVATION_TOKEN: The RESERVATION-TOKEN attribute as defined"]
#[doc = " by TURN draft 09 and 12"]
#[doc = " @STUN_ATTRIBUTE_CONNECT_STAT: The CONNECT-STAT attribute as defined by TURN"]
#[doc = " draft 04"]
#[doc = " @STUN_ATTRIBUTE_PRIORITY: The PRIORITY attribute as defined by ICE draft 19"]
#[doc = " @STUN_ATTRIBUTE_USE_CANDIDATE: The USE-CANDIDATE attribute as defined by"]
#[doc = " ICE draft 19"]
#[doc = " @STUN_ATTRIBUTE_OPTIONS: The OPTIONS optional attribute as defined by"]
#[doc = " libjingle"]
#[doc = " @STUN_ATTRIBUTE_MS_VERSION: The MS-VERSION optional attribute as defined"]
#[doc = " by [MS-TURN]"]
#[doc = " @STUN_ATTRIBUTE_MS_XOR_MAPPED_ADDRESS: The XOR-MAPPED-ADDRESS optional"]
#[doc = " attribute as defined by [MS-TURN]"]
#[doc = " @STUN_ATTRIBUTE_SOFTWARE: The SOFTWARE optional attribute as defined by RFC5389"]
#[doc = " @STUN_ATTRIBUTE_ALTERNATE_SERVER: The ALTERNATE-SERVER optional attribute as"]
#[doc = " defined by RFC5389"]
#[doc = " @STUN_ATTRIBUTE_FINGERPRINT: The FINGERPRINT optional attribute as defined"]
#[doc = " by RFC5389"]
#[doc = " @STUN_ATTRIBUTE_ICE_CONTROLLED: The ICE-CONTROLLED optional attribute as"]
#[doc = " defined by ICE draft 19"]
#[doc = " @STUN_ATTRIBUTE_ICE_CONTROLLING: The ICE-CONTROLLING optional attribute as"]
#[doc = " defined by ICE draft 19"]
#[doc = " @STUN_ATTRIBUTE_MS_SEQUENCE_NUMBER: The MS-SEQUENCE NUMBER optional attribute"]
#[doc = " as defined by [MS-TURN]"]
#[doc = " @STUN_ATTRIBUTE_CANDIDATE_IDENTIFIER: The CANDIDATE-IDENTIFIER optional"]
#[doc = " attribute as defined by [MS-ICE2]"]
#[doc = " @STUN_ATTRIBUTE_MS_IMPLEMENTATION_VERSION: The IMPLEMENTATION-VERSION"]
#[doc = " optional attribute as defined by [MS-ICE2]"]
#[doc = " @STUN_ATTRIBUTE_NOMINATION: The NOMINATION attribute as defined by"]
#[doc = " draft-thatcher-ice-renomination-00 and deployed in Google Chrome"]
#[doc = ""]
#[doc = " Known STUN attribute types as defined by various RFCs and drafts"]
pub type StunAttribute = i32;
#[doc = " StunTransactionId:"]
#[doc = ""]
#[doc = " A type that holds a STUN transaction id."]
pub type StunTransactionId = [u8; 16usize];
pub const StunError_STUN_ERROR_TRY_ALTERNATE: StunError = 300;
pub const StunError_STUN_ERROR_BAD_REQUEST: StunError = 400;
pub const StunError_STUN_ERROR_UNAUTHORIZED: StunError = 401;
pub const StunError_STUN_ERROR_UNKNOWN_ATTRIBUTE: StunError = 420;
pub const StunError_STUN_ERROR_ALLOCATION_MISMATCH: StunError = 437;
pub const StunError_STUN_ERROR_STALE_NONCE: StunError = 438;
pub const StunError_STUN_ERROR_ACT_DST_ALREADY: StunError = 439;
pub const StunError_STUN_ERROR_UNSUPPORTED_FAMILY: StunError = 440;
pub const StunError_STUN_ERROR_WRONG_CREDENTIALS: StunError = 441;
pub const StunError_STUN_ERROR_UNSUPPORTED_TRANSPORT: StunError = 442;
pub const StunError_STUN_ERROR_INVALID_IP: StunError = 443;
pub const StunError_STUN_ERROR_INVALID_PORT: StunError = 444;
pub const StunError_STUN_ERROR_OP_TCP_ONLY: StunError = 445;
pub const StunError_STUN_ERROR_CONN_ALREADY: StunError = 446;
pub const StunError_STUN_ERROR_ALLOCATION_QUOTA_REACHED: StunError = 486;
pub const StunError_STUN_ERROR_ROLE_CONFLICT: StunError = 487;
pub const StunError_STUN_ERROR_SERVER_ERROR: StunError = 500;
pub const StunError_STUN_ERROR_SERVER_CAPACITY: StunError = 507;
pub const StunError_STUN_ERROR_INSUFFICIENT_CAPACITY: StunError = 508;
pub const StunError_STUN_ERROR_MAX: StunError = 699;
#[doc = " StunError:"]
#[doc = " @STUN_ERROR_TRY_ALTERNATE: The ERROR-CODE value for the"]
#[doc = " \"Try Alternate\" error as defined in RFC5389"]
#[doc = " @STUN_ERROR_BAD_REQUEST: The ERROR-CODE value for the"]
#[doc = " \"Bad Request\" error as defined in RFC5389"]
#[doc = " @STUN_ERROR_UNAUTHORIZED: The ERROR-CODE value for the"]
#[doc = " \"Unauthorized\" error as defined in RFC5389"]
#[doc = " @STUN_ERROR_UNKNOWN_ATTRIBUTE: The ERROR-CODE value for the"]
#[doc = " \"Unknown Attribute\" error as defined in RFC5389"]
#[doc = " @STUN_ERROR_ALLOCATION_MISMATCH:The ERROR-CODE value for the"]
#[doc = " \"Allocation Mismatch\" error as defined in TURN draft 12."]
#[doc = " Equivalent to the \"No Binding\" error defined in TURN draft 04."]
#[doc = " @STUN_ERROR_STALE_NONCE: The ERROR-CODE value for the"]
#[doc = " \"Stale Nonce\" error as defined in RFC5389"]
#[doc = " @STUN_ERROR_ACT_DST_ALREADY: The ERROR-CODE value for the"]
#[doc = " \"Active Destination Already Set\" error as defined in TURN draft 04."]
#[doc = " @STUN_ERROR_UNSUPPORTED_FAMILY: The ERROR-CODE value for the"]
#[doc = " \"Address Family not Supported\" error as defined in TURN IPV6 Draft 05."]
#[doc = " @STUN_ERROR_WRONG_CREDENTIALS: The ERROR-CODE value for the"]
#[doc = " \"Wrong Credentials\" error as defined in TURN Draft 12."]
#[doc = " @STUN_ERROR_UNSUPPORTED_TRANSPORT:he ERROR-CODE value for the"]
#[doc = " \"Unsupported Transport Protocol\" error as defined in TURN Draft 12."]
#[doc = " @STUN_ERROR_INVALID_IP: The ERROR-CODE value for the"]
#[doc = " \"Invalid IP Address\" error as defined in TURN draft 04."]
#[doc = " @STUN_ERROR_INVALID_PORT: The ERROR-CODE value for the"]
#[doc = " \"Invalid Port\" error as defined in TURN draft 04."]
#[doc = " @STUN_ERROR_OP_TCP_ONLY: The ERROR-CODE value for the"]
#[doc = " \"Operation for TCP Only\" error as defined in TURN draft 04."]
#[doc = " @STUN_ERROR_CONN_ALREADY: The ERROR-CODE value for the"]
#[doc = " \"Connection Already Exists\" error as defined in TURN draft 04."]
#[doc = " @STUN_ERROR_ALLOCATION_QUOTA_REACHED: The ERROR-CODE value for the"]
#[doc = " \"Allocation Quota Reached\" error as defined in TURN draft 12."]
#[doc = " @STUN_ERROR_ROLE_CONFLICT:The ERROR-CODE value for the"]
#[doc = " \"Role Conflict\" error as defined in ICE draft 19."]
#[doc = " @STUN_ERROR_SERVER_ERROR: The ERROR-CODE value for the"]
#[doc = " \"Server Error\" error as defined in RFC5389"]
#[doc = " @STUN_ERROR_SERVER_CAPACITY: The ERROR-CODE value for the"]
#[doc = " \"Insufficient Capacity\" error as defined in TURN draft 04."]
#[doc = " @STUN_ERROR_INSUFFICIENT_CAPACITY: The ERROR-CODE value for the"]
#[doc = " \"Insufficient Capacity\" error as defined in TURN draft 12."]
#[doc = " @STUN_ERROR_MAX: The maximum possible ERROR-CODE value as defined by RFC 5389."]
#[doc = ""]
#[doc = " STUN error codes as defined by various RFCs and drafts"]
pub type StunError = i32;
pub const StunMessageReturn_STUN_MESSAGE_RETURN_SUCCESS: StunMessageReturn = 0;
pub const StunMessageReturn_STUN_MESSAGE_RETURN_NOT_FOUND: StunMessageReturn = 1;
pub const StunMessageReturn_STUN_MESSAGE_RETURN_INVALID: StunMessageReturn = 2;
pub const StunMessageReturn_STUN_MESSAGE_RETURN_NOT_ENOUGH_SPACE: StunMessageReturn = 3;
pub const StunMessageReturn_STUN_MESSAGE_RETURN_UNSUPPORTED_ADDRESS: StunMessageReturn = 4;
#[doc = " StunMessageReturn:"]
#[doc = " @STUN_MESSAGE_RETURN_SUCCESS: The operation was successful"]
#[doc = " @STUN_MESSAGE_RETURN_NOT_FOUND: The attribute was not found"]
#[doc = " @STUN_MESSAGE_RETURN_INVALID: The argument or data is invalid"]
#[doc = " @STUN_MESSAGE_RETURN_NOT_ENOUGH_SPACE: There is not enough space in the"]
#[doc = " message to append data to it, or not enough in an argument to fill it with"]
#[doc = " the data requested."]
#[doc = " @STUN_MESSAGE_RETURN_UNSUPPORTED_ADDRESS: The address in the arguments or in"]
#[doc = " the STUN message is not supported."]
#[doc = ""]
#[doc = " The return value of most stun_message_* functions."]
#[doc = " This enum will report on whether an operation was successful or not"]
#[doc = " and what error occured if any."]
pub type StunMessageReturn = i32;
#[doc = " StunMessage:"]
#[doc = " @agent: The agent that created or validated this message"]
#[doc = " @buffer: The buffer containing the STUN message"]
#[doc = " @buffer_len: The length of the buffer (not the size of the message)"]
#[doc = " @key: The short term credentials key to use for authentication validation"]
#[doc = " or that was used to finalize this message"]
#[doc = " @key_len: The length of the associated key"]
#[doc = " @long_term_key: The long term credential key to use for authentication"]
#[doc = " validation or that was used to finalize this message"]
#[doc = " @long_term_valid: Whether or not the #long_term_key variable contains valid"]
#[doc = " data"]
#[doc = ""]
#[doc = " This structure represents a STUN message"]
#[repr(C)]
pub struct _StunMessage {
    pub agent: *mut StunAgent,
    pub buffer: *mut u8,
    pub buffer_len: size_t,
    pub key: *mut u8,
    pub key_len: size_t,
    pub long_term_key: [u8; 16usize],
    pub long_term_valid: bool,
}
#[test]
fn bindgen_test_layout__StunMessage() {
    assert_eq!(
        ::std::mem::size_of::<_StunMessage>(),
        64usize,
        concat!("Size of: ", stringify!(_StunMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_StunMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_StunMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_StunMessage>())).agent as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(_StunMessage),
        "::",
        stringify!(agent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_StunMessage>())).buffer as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(_StunMessage),
        "::",
        stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_StunMessage>())).buffer_len as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(_StunMessage),
        "::",
        stringify!(buffer_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_StunMessage>())).key as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(_StunMessage),
        "::",
        stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_StunMessage>())).key_len as *const _ as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(_StunMessage),
        "::",
        stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_StunMessage>())).long_term_key as *const _ as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(_StunMessage),
        "::",
        stringify!(long_term_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_StunMessage>())).long_term_valid as *const _ as usize },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(_StunMessage),
        "::",
        stringify!(long_term_valid)
        )
    );
}
extern "C" {
    #[doc = " stun_message_init:"]
    #[doc = " @msg: The #StunMessage to initialize"]
    #[doc = " @c: STUN message class (host byte order)"]
    #[doc = " @m: STUN message method (host byte order)"]
    #[doc = " @id: 16-bytes transaction ID"]
    #[doc = ""]
    #[doc = " Initializes a STUN message buffer, with no attributes."]
    #[doc = " Returns: %TRUE if the initialization was successful"]
    pub fn stun_message_init(
        msg: *mut StunMessage,
        c: StunClass,
        m: StunMethod,
        id: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = " stun_message_length:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = ""]
    #[doc = " Get the length of the message (including the header)"]
    #[doc = ""]
    #[doc = " Returns: The length of the message"]
    pub fn stun_message_length(msg: *const StunMessage) -> u16;
}
extern "C" {
    #[doc = " stun_message_find:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to find"]
    #[doc = " @palen: A pointer to store the length of the attribute"]
    #[doc = ""]
    #[doc = " Finds an attribute in a STUN message and fetches its content"]
    #[doc = ""]
    #[doc = " Returns: A pointer to the start of the attribute payload if found,"]
    #[doc = " otherwise NULL."]
    pub fn stun_message_find(
        msg: *const StunMessage,
        type_: StunAttribute,
        palen: *mut u16,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " stun_message_find_flag:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to find"]
    #[doc = ""]
    #[doc = " Looks for a flag attribute within a valid STUN message."]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    #[doc = " %STUN_MESSAGE_RETURN_INVALID is returned if the attribute's size is not zero."]
    pub fn stun_message_find_flag(
        msg: *const StunMessage,
        type_: StunAttribute,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_find32:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to find"]
    #[doc = " @pval: A pointer where to store the value (host byte order)"]
    #[doc = ""]
    #[doc = " Extracts a 32-bits attribute from a STUN message."]
    #[doc = ""]
    #[doc = " Returns:  A #StunMessageReturn value."]
    #[doc = " %STUN_MESSAGE_RETURN_INVALID is returned if the attribute's size is not"]
    #[doc = " 4 bytes."]
    pub fn stun_message_find32(
        msg: *const StunMessage,
        type_: StunAttribute,
        pval: *mut u32,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_find64:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to find"]
    #[doc = " @pval: A pointer where to store the value (host byte order)"]
    #[doc = ""]
    #[doc = " Extracts a 64-bits attribute from a STUN message."]
    #[doc = ""]
    #[doc = " Returns:  A #StunMessageReturn value."]
    #[doc = " %STUN_MESSAGE_RETURN_INVALID is returned if the attribute's size is not"]
    #[doc = " 8 bytes."]
    pub fn stun_message_find64(
        msg: *const StunMessage,
        type_: StunAttribute,
        pval: *mut u64,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_find_string:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to find"]
    #[doc = " @buf: A pointer where to store the data"]
    #[doc = " @buflen: The length of the buffer"]
    #[doc = ""]
    #[doc = " Extracts an UTF-8 string from a valid STUN message."]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    #[doc = " %STUN_MESSAGE_RETURN_INVALID is returned if the attribute is improperly"]
    #[doc = " encoded"]
    #[doc = " %STUN_MESSAGE_RETURN_NOT_ENOUGH_SPACE is return if the buffer size is too"]
    #[doc = " small to hold the string"]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "The string will be nul-terminated."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    pub fn stun_message_find_string(
        msg: *const StunMessage,
        type_: StunAttribute,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_find_addr:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to find"]
    #[doc = " @addr: The #sockaddr to be filled"]
    #[doc = " @addrlen: The size of the @addr variable. Must be set to the size of the"]
    #[doc = " @addr socket address and will be set to the size of the extracted socket"]
    #[doc = " address."]
    #[doc = ""]
    #[doc = " Extracts a network address attribute from a STUN message."]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    #[doc = " %STUN_MESSAGE_RETURN_INVALID is returned if the attribute payload size is"]
    #[doc = " wrong or if the @addrlen is too small"]
    #[doc = " %STUN_MESSAGE_RETURN_UNSUPPORTED_ADDRESS if the address family is unknown."]
    pub fn stun_message_find_addr(
        msg: *const StunMessage,
        type_: StunAttribute,
        addr: *mut sockaddr_storage,
        addrlen: *mut socklen_t,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_find_xor_addr:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to find"]
    #[doc = " @addr: The #sockaddr to be filled"]
    #[doc = " @addrlen: The size of the @addr variable. Must be set to the size of the"]
    #[doc = " @addr socket address and will be set to the size of the"]
    #[doc = " extracted socket address."]
    #[doc = ""]
    #[doc = " Extracts an obfuscated network address attribute from a STUN message."]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    #[doc = " %STUN_MESSAGE_RETURN_INVALID is returned if the attribute payload size is"]
    #[doc = " wrong or if the @addrlen is too small"]
    #[doc = " %STUN_MESSAGE_RETURN_UNSUPPORTED_ADDRESS if the address family is unknown."]
    pub fn stun_message_find_xor_addr(
        msg: *const StunMessage,
        type_: StunAttribute,
        addr: *mut sockaddr_storage,
        addrlen: *mut socklen_t,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_find_xor_addr_full:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to find"]
    #[doc = " @addr: The #sockaddr to be filled"]
    #[doc = " @addrlen: The size of the @addr variable. Must be set to the size of the"]
    #[doc = " @addr socket address and will be set to the size of the"]
    #[doc = " extracted socket address."]
    #[doc = " @magic_cookie: The magic cookie to use to XOR the address."]
    #[doc = ""]
    #[doc = " Extracts an obfuscated network address attribute from a STUN message."]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    #[doc = " %STUN_MESSAGE_RETURN_INVALID is returned if the attribute payload size is"]
    #[doc = " wrong or if the @addrlen is too small"]
    #[doc = " %STUN_MESSAGE_RETURN_UNSUPPORTED_ADDRESS if the address family is unknown."]
    pub fn stun_message_find_xor_addr_full(
        msg: *const StunMessage,
        type_: StunAttribute,
        addr: *mut sockaddr_storage,
        addrlen: *mut socklen_t,
        magic_cookie: u32,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_find_error:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @code: A  pointer where to store the value"]
    #[doc = ""]
    #[doc = " Extract the error response code from a STUN message"]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    #[doc = " %STUN_MESSAGE_RETURN_INVALID is returned if the value is invalid"]
    pub fn stun_message_find_error(
        msg: *const StunMessage,
        code: *mut ::std::os::raw::c_int,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_append:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to append"]
    #[doc = " @length: The length of the attribute"]
    #[doc = ""]
    #[doc = " Reserves room for appending an attribute to an unfinished STUN message."]
    #[doc = ""]
    #[doc = " Returns: A pointer to an unitialized buffer of @length bytes to"]
    #[doc = " where the attribute payload must be written, or NULL if there is not"]
    #[doc = " enough room in the STUN message buffer."]
    pub fn stun_message_append(
        msg: *mut StunMessage,
        type_: StunAttribute,
        length: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " stun_message_append_bytes:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to append"]
    #[doc = " @data: The data to append"]
    #[doc = " @len: The length of the attribute"]
    #[doc = ""]
    #[doc = " Appends a binary value to a STUN message"]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    pub fn stun_message_append_bytes(
        msg: *mut StunMessage,
        type_: StunAttribute,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_append_flag:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to append"]
    #[doc = ""]
    #[doc = " Appends an empty flag attribute to a STUN message"]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    pub fn stun_message_append_flag(
        msg: *mut StunMessage,
        type_: StunAttribute,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_append32:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to append"]
    #[doc = " @value: The value to append (host byte order)"]
    #[doc = ""]
    #[doc = " Appends a 32-bits value attribute to a STUN message"]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    pub fn stun_message_append32(
        msg: *mut StunMessage,
        type_: StunAttribute,
        value: u32,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_append64:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to append"]
    #[doc = " @value: The value to append (host byte order)"]
    #[doc = ""]
    #[doc = " Appends a 64-bits value attribute to a STUN message"]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    pub fn stun_message_append64(
        msg: *mut StunMessage,
        type_: StunAttribute,
        value: u64,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_append_string:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to append"]
    #[doc = " @str: The string to append"]
    #[doc = ""]
    #[doc = " Adds an attribute from a nul-terminated string to a STUN message"]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    pub fn stun_message_append_string(
        msg: *mut StunMessage,
        type_: StunAttribute,
        str: *const ::std::os::raw::c_char,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_append_addr:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to append"]
    #[doc = " @addr: The #sockaddr to be append"]
    #[doc = " @addrlen: The size of the @addr variable."]
    #[doc = ""]
    #[doc = " Append a network address attribute to a STUN message"]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    #[doc = " %STUN_MESSAGE_RETURN_INVALID is returned if the @addrlen is too small"]
    #[doc = " %STUN_MESSAGE_RETURN_UNSUPPORTED_ADDRESS if the address family is unknown."]
    pub fn stun_message_append_addr(
        msg: *mut StunMessage,
        type_: StunAttribute,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_append_xor_addr:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to append"]
    #[doc = " @addr: The #sockaddr to be append"]
    #[doc = " @addrlen: The size of the @addr variable."]
    #[doc = ""]
    #[doc = " Append an obfuscated network address attribute to a STUN message"]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    #[doc = " %STUN_MESSAGE_RETURN_INVALID is returned if the @addrlen is too small"]
    #[doc = " %STUN_MESSAGE_RETURN_UNSUPPORTED_ADDRESS if the address family is unknown."]
    pub fn stun_message_append_xor_addr(
        msg: *mut StunMessage,
        type_: StunAttribute,
        addr: *const sockaddr_storage,
        addrlen: socklen_t,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_append_xor_addr_full:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to append"]
    #[doc = " @addr: The #sockaddr to be append"]
    #[doc = " @addrlen: The size of the @addr variable."]
    #[doc = " @magic_cookie: The magic cookie to use to XOR the address."]
    #[doc = ""]
    #[doc = " Append an obfuscated network address attribute from a STUN message."]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    #[doc = " %STUN_MESSAGE_RETURN_INVALID is returned if the @addrlen is too small"]
    #[doc = " %STUN_MESSAGE_RETURN_UNSUPPORTED_ADDRESS if the address family is unknown."]
    pub fn stun_message_append_xor_addr_full(
        msg: *mut StunMessage,
        type_: StunAttribute,
        addr: *const sockaddr_storage,
        addrlen: socklen_t,
        magic_cookie: u32,
    ) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_append_error:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @code: The error code value"]
    #[doc = ""]
    #[doc = " Appends the ERROR-CODE attribute to the STUN message and fills it according"]
    #[doc = " to #code"]
    #[doc = ""]
    #[doc = " Returns: A #StunMessageReturn value."]
    pub fn stun_message_append_error(msg: *mut StunMessage, code: StunError) -> StunMessageReturn;
}
extern "C" {
    #[doc = " stun_message_validate_buffer_length:"]
    #[doc = " @msg: The buffer to validate"]
    #[doc = " @length: The length of the buffer"]
    #[doc = " @has_padding: Set TRUE if attributes should be padded to multiple of 4 bytes"]
    #[doc = ""]
    #[doc = " This function will take a data buffer and will try to validate whether it is"]
    #[doc = " a STUN message or if it's not or if it's an incomplete STUN message and will"]
    #[doc = " provide us with the length of the STUN message."]
    #[doc = ""]
    #[doc = " Returns: The length of the valid STUN message in the buffer."]
    #[doc = " <para> See also: #STUN_MESSAGE_BUFFER_INCOMPLETE </para>"]
    #[doc = " <para> See also: #STUN_MESSAGE_BUFFER_INVALID </para>"]
    pub fn stun_message_validate_buffer_length(
        msg: *const u8,
        length: size_t,
        has_padding: bool,
    ) -> ::std::os::raw::c_int;
}
#[doc = " StunInputVector:"]
#[doc = " @buffer: a buffer containing already-received binary data"]
#[doc = " @size: length of @buffer, in bytes"]
#[doc = ""]
#[doc = " Container for a single buffer which also stores its length. This is designed"]
#[doc = " for vectored I/O: typically an array of #StunInputVectors is passed to"]
#[doc = " functions, providing multiple buffers which store logically contiguous"]
#[doc = " received data."]
#[doc = ""]
#[doc = " This is guaranteed to be layed out identically in memory to #GInputVector."]
#[doc = ""]
#[doc = " Since: 0.1.5"]
#[repr(C)]
pub struct StunInputVector {
    pub buffer: *const u8,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_StunInputVector() {
    assert_eq!(
        ::std::mem::size_of::<StunInputVector>(),
        16usize,
        concat!("Size of: ", stringify!(StunInputVector))
    );
    assert_eq!(
        ::std::mem::align_of::<StunInputVector>(),
        8usize,
        concat!("Alignment of ", stringify!(StunInputVector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StunInputVector>())).buffer as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(StunInputVector),
        "::",
        stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StunInputVector>())).size as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(StunInputVector),
        "::",
        stringify!(size)
        )
    );
}
extern "C" {
    #[doc = " stun_message_validate_buffer_length_fast:"]
    #[doc = " @buffers: (array length=n_buffers) (in caller-allocated): array of contiguous"]
    #[doc = " #StunInputVectors containing already-received message data"]
    #[doc = " @n_buffers: number of entries in @buffers or if -1 , then buffers is"]
    #[doc = "  terminated by a #StunInputVector with the buffer pointer being %NULL."]
    #[doc = " @total_length: total number of valid bytes stored consecutively in @buffers"]
    #[doc = " @has_padding: %TRUE if attributes should be padded to 4-byte boundaries"]
    #[doc = ""]
    #[doc = " Quickly validate whether the message in the given @buffers is potentially a"]
    #[doc = " valid STUN message, an incomplete STUN message, or if its definitely not one"]
    #[doc = " at all."]
    #[doc = ""]
    #[doc = " This is designed as a first-pass validation only, and does not check the"]
    #[doc = " messages attributes for validity. If this function returns success, the"]
    #[doc = " buffers can be compacted and a more thorough validation can be performed"]
    #[doc = " using stun_message_validate_buffer_length(). If it fails, the buffers"]
    #[doc = " definitely do not contain a complete, valid STUN message."]
    #[doc = ""]
    #[doc = " Returns: The length of the valid STUN message in the buffer, or zero or -1 on"]
    #[doc = " failure"]
    #[doc = " <para> See also: #STUN_MESSAGE_BUFFER_INCOMPLETE </para>"]
    #[doc = " <para> See also: #STUN_MESSAGE_BUFFER_INVALID </para>"]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn stun_message_validate_buffer_length_fast(
        buffers: *mut StunInputVector,
        n_buffers: ::std::os::raw::c_int,
        total_length: size_t,
        has_padding: bool,
    ) -> SSIZE_T;
}
extern "C" {
    #[doc = " stun_message_id:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @id: The #StunTransactionId to fill"]
    #[doc = ""]
    #[doc = " Retreive the STUN transaction id from a STUN message"]
    pub fn stun_message_id(msg: *const StunMessage, id: *mut u8);
}
extern "C" {
    #[doc = " stun_message_get_class:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = ""]
    #[doc = " Retreive the STUN class from a STUN message"]
    #[doc = ""]
    #[doc = " Returns: The #StunClass"]
    pub fn stun_message_get_class(msg: *const StunMessage) -> StunClass;
}
extern "C" {
    #[doc = " stun_message_get_method:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = ""]
    #[doc = " Retreive the STUN method from a STUN message"]
    #[doc = ""]
    #[doc = " Returns: The #StunMethod"]
    pub fn stun_message_get_method(msg: *const StunMessage) -> StunMethod;
}
extern "C" {
    #[doc = " stun_message_has_attribute:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = " @type: The #StunAttribute to look for"]
    #[doc = ""]
    #[doc = " Checks if an attribute is present within a STUN message."]
    #[doc = ""]
    #[doc = " Returns: %TRUE if the attribute is found, %FALSE otherwise"]
    pub fn stun_message_has_attribute(msg: *const StunMessage, type_: StunAttribute) -> bool;
}
extern "C" {
    #[doc = " stun_message_has_cookie:"]
    #[doc = " @msg: The #StunMessage"]
    #[doc = ""]
    #[doc = " Checks if the STUN message has a RFC5389 compatible cookie"]
    #[doc = ""]
    #[doc = " Returns: %TRUE if the cookie is present, %FALSE otherwise"]
    pub fn stun_message_has_cookie(msg: *const StunMessage) -> bool;
}
extern "C" {
    #[doc = " stun_optional:"]
    #[doc = " @t: An attribute type"]
    #[doc = ""]
    #[doc = " Helper function that checks whether a STUN attribute is a mandatory"]
    #[doc = " or an optional attribute"]
    #[doc = ""]
    #[doc = " Returns: %TRUE if the attribute is an optional one"]
    pub fn stun_optional(t: u16) -> bool;
}
extern "C" {
    #[doc = " stun_strerror:"]
    #[doc = " @code: host-byte order error code"]
    #[doc = ""]
    #[doc = " Transforms a STUN error-code into a human readable string"]
    #[doc = ""]
    #[doc = " Returns: A static pointer to a nul-terminated error message string."]
    pub fn stun_strerror(code: StunError) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " stun_debug_enable:"]
    #[doc = ""]
    #[doc = " Enable debug messages to stderr"]
    pub fn stun_debug_enable();
}
extern "C" {
    #[doc = " stun_debug_disable:"]
    #[doc = ""]
    #[doc = " Disable debug messages to stderr"]
    pub fn stun_debug_disable();
}
pub type StunDebugHandler = u64;
extern "C" {
    #[doc = " stun_set_debug_handler:"]
    #[doc = " @handler: (nullable): Handler for STUN debug messages, or %NULL to use the"]
    #[doc = "   default"]
    #[doc = ""]
    #[doc = " Set a callback function to be invoked for each debug message from the STUN"]
    #[doc = " code. The callback will only be invoked if STUN debugging is enabled using"]
    #[doc = " stun_debug_enable()."]
    #[doc = ""]
    #[doc = " The default callback prints the formatted debug message to stderr."]
    pub fn stun_set_debug_handler(handler: StunDebugHandler);
}
extern "C" {
    pub fn stun_debug(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn stun_debug_bytes(
        prefix: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    );
}
pub const StunCompatibility_STUN_COMPATIBILITY_RFC3489: StunCompatibility = 0;
pub const StunCompatibility_STUN_COMPATIBILITY_RFC5389: StunCompatibility = 1;
pub const StunCompatibility_STUN_COMPATIBILITY_MSICE2: StunCompatibility = 2;
pub const StunCompatibility_STUN_COMPATIBILITY_OC2007: StunCompatibility = 3;
pub const StunCompatibility_STUN_COMPATIBILITY_WLM2009: StunCompatibility = 2;
pub const StunCompatibility_STUN_COMPATIBILITY_LAST: StunCompatibility = 3;
#[doc = " StunCompatibility:"]
#[doc = " @STUN_COMPATIBILITY_RFC3489: Use the STUN specifications compatible with"]
#[doc = " RFC 3489"]
#[doc = " @STUN_COMPATIBILITY_RFC5389: Use the STUN specifications compatible with"]
#[doc = " RFC 5389"]
#[doc = " @STUN_COMPATIBILITY_MSICE2: Use the STUN specifications compatible with"]
#[doc = " [MS-ICE2] (a mix between RFC3489 and RFC5389)"]
#[doc = " @STUN_COMPATIBILITY_OC2007: Use the STUN specifications compatible with"]
#[doc = " Microsoft Office Communicator 2007 (basically RFC3489 with swapped"]
#[doc = " REALM and NONCE attribute hex IDs, attributes are not aligned)"]
#[doc = " @STUN_COMPATIBILITY_WLM2009: An alias for @STUN_COMPATIBILITY_MSICE2"]
#[doc = " @STUN_COMPATIBILITY_LAST: Dummy last compatibility mode"]
#[doc = ""]
#[doc = " Enum that specifies the STUN compatibility mode of the #StunAgent"]
#[doc = ""]
#[doc = " <warning>@STUN_COMPATIBILITY_WLM2009 is deprecated and should not be used"]
#[doc = " in newly-written code. It is kept for compatibility reasons and represents"]
#[doc = " the same compatibility as @STUN_COMPATIBILITY_MSICE2.</warning>"]
pub type StunCompatibility = i32;
pub const StunValidationStatus_STUN_VALIDATION_SUCCESS: StunValidationStatus = 0;
pub const StunValidationStatus_STUN_VALIDATION_NOT_STUN: StunValidationStatus = 1;
pub const StunValidationStatus_STUN_VALIDATION_INCOMPLETE_STUN: StunValidationStatus = 2;
pub const StunValidationStatus_STUN_VALIDATION_BAD_REQUEST: StunValidationStatus = 3;
pub const StunValidationStatus_STUN_VALIDATION_UNAUTHORIZED_BAD_REQUEST: StunValidationStatus = 4;
pub const StunValidationStatus_STUN_VALIDATION_UNAUTHORIZED: StunValidationStatus = 5;
pub const StunValidationStatus_STUN_VALIDATION_UNMATCHED_RESPONSE: StunValidationStatus = 6;
pub const StunValidationStatus_STUN_VALIDATION_UNKNOWN_REQUEST_ATTRIBUTE: StunValidationStatus = 7;
pub const StunValidationStatus_STUN_VALIDATION_UNKNOWN_ATTRIBUTE: StunValidationStatus = 8;
#[doc = " StunValidationStatus:"]
#[doc = " @STUN_VALIDATION_SUCCESS: The message is validated"]
#[doc = " @STUN_VALIDATION_NOT_STUN: This is not a valid STUN message"]
#[doc = " @STUN_VALIDATION_INCOMPLETE_STUN: The message seems to be valid but incomplete"]
#[doc = " @STUN_VALIDATION_BAD_REQUEST: The message does not have the cookie or the"]
#[doc = " fingerprint while the agent needs it with its usage"]
#[doc = " @STUN_VALIDATION_UNAUTHORIZED_BAD_REQUEST: The message is valid but"]
#[doc = " unauthorized with no username and message-integrity attributes."]
#[doc = " A BAD_REQUEST error must be generated"]
#[doc = " @STUN_VALIDATION_UNAUTHORIZED: The message is valid but unauthorized as"]
#[doc = " the username/password do not match."]
#[doc = " An UNAUTHORIZED error must be generated"]
#[doc = " @STUN_VALIDATION_UNMATCHED_RESPONSE: The message is valid but this is a"]
#[doc = " response/error that doesn't match a previously sent request"]
#[doc = " @STUN_VALIDATION_UNKNOWN_REQUEST_ATTRIBUTE: The message is valid but"]
#[doc = " contains one or more unknown comprehension attributes."]
#[doc = " stun_agent_build_unknown_attributes_error() should be called"]
#[doc = " @STUN_VALIDATION_UNKNOWN_ATTRIBUTE: The message is valid but contains one"]
#[doc = " or more unknown comprehension attributes. This is a response, or error,"]
#[doc = " or indication message and no error response should be sent"]
#[doc = ""]
#[doc = " This enum is used as the return value of stun_agent_validate() and represents"]
#[doc = " the status result of the validation of a STUN message."]
pub type StunValidationStatus = i32;
pub const StunAgentUsageFlags_STUN_AGENT_USAGE_SHORT_TERM_CREDENTIALS: StunAgentUsageFlags = 1;
pub const StunAgentUsageFlags_STUN_AGENT_USAGE_LONG_TERM_CREDENTIALS: StunAgentUsageFlags = 2;
pub const StunAgentUsageFlags_STUN_AGENT_USAGE_USE_FINGERPRINT: StunAgentUsageFlags = 4;
pub const StunAgentUsageFlags_STUN_AGENT_USAGE_ADD_SOFTWARE: StunAgentUsageFlags = 8;
pub const StunAgentUsageFlags_STUN_AGENT_USAGE_IGNORE_CREDENTIALS: StunAgentUsageFlags = 16;
pub const StunAgentUsageFlags_STUN_AGENT_USAGE_NO_INDICATION_AUTH: StunAgentUsageFlags = 32;
pub const StunAgentUsageFlags_STUN_AGENT_USAGE_FORCE_VALIDATER: StunAgentUsageFlags = 64;
pub const StunAgentUsageFlags_STUN_AGENT_USAGE_NO_ALIGNED_ATTRIBUTES: StunAgentUsageFlags = 128;
#[doc = " StunAgentUsageFlags:"]
#[doc = " @STUN_AGENT_USAGE_SHORT_TERM_CREDENTIALS: The agent should be using the short"]
#[doc = " term credentials mechanism for authenticating STUN messages"]
#[doc = " @STUN_AGENT_USAGE_LONG_TERM_CREDENTIALS: The agent should be using the long"]
#[doc = " term credentials mechanism for authenticating STUN messages"]
#[doc = " @STUN_AGENT_USAGE_USE_FINGERPRINT: The agent should add the FINGERPRINT"]
#[doc = " attribute to the STUN messages it creates."]
#[doc = " @STUN_AGENT_USAGE_ADD_SOFTWARE: The agent should add the SOFTWARE attribute"]
#[doc = " to the STUN messages it creates. Calling nice_agent_set_software() will have"]
#[doc = " the same effect as enabling this Usage. STUN Indications do not have the"]
#[doc = " SOFTWARE attributes added to them though. The SOFTWARE attribute is only"]
#[doc = " added for the RFC5389 and MSICE2 compatibility modes."]
#[doc = " @STUN_AGENT_USAGE_IGNORE_CREDENTIALS: The agent should ignore any credentials"]
#[doc = " in the STUN messages it receives (the MESSAGE-INTEGRITY attribute"]
#[doc = " will never be validated by stun_agent_validate())"]
#[doc = " @STUN_AGENT_USAGE_NO_INDICATION_AUTH: The agent should ignore credentials"]
#[doc = " in the STUN messages it receives if the #StunClass of the message is"]
#[doc = " #STUN_INDICATION (some implementation require #STUN_INDICATION messages to"]
#[doc = " be authenticated, while others never add a MESSAGE-INTEGRITY attribute to a"]
#[doc = " #STUN_INDICATION message)"]
#[doc = " @STUN_AGENT_USAGE_FORCE_VALIDATER: The agent should always try to validate"]
#[doc = " the password of a STUN message, even if it already knows what the password"]
#[doc = " should be (a response to a previously created request). This means that the"]
#[doc = " #StunMessageIntegrityValidate callback will always be called when there is"]
#[doc = " a MESSAGE-INTEGRITY attribute."]
#[doc = " @STUN_AGENT_USAGE_NO_ALIGNED_ATTRIBUTES: The agent should not assume STUN"]
#[doc = " attributes are aligned on 32-bit boundaries when parsing messages and also"]
#[doc = " do not add padding when creating messages."]
#[doc = ""]
#[doc = " This enum defines a bitflag usages for a #StunAgent and they will define how"]
#[doc = " the agent should behave, independently of the compatibility mode it uses."]
#[doc = " <para> See also: stun_agent_init() </para>"]
#[doc = " <para> See also: stun_agent_validate() </para>"]
pub type StunAgentUsageFlags = i32;
#[repr(C)]
pub struct StunAgentSavedIds {
    pub id: StunTransactionId,
    pub method: StunMethod,
    pub key: *mut u8,
    pub key_len: size_t,
    pub long_term_key: [u8; 16usize],
    pub long_term_valid: bool,
    pub valid: bool,
}
#[test]
fn bindgen_test_layout_StunAgentSavedIds() {
    assert_eq!(
        ::std::mem::size_of::<StunAgentSavedIds>(),
        64usize,
        concat!("Size of: ", stringify!(StunAgentSavedIds))
    );
    assert_eq!(
        ::std::mem::align_of::<StunAgentSavedIds>(),
        8usize,
        concat!("Alignment of ", stringify!(StunAgentSavedIds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StunAgentSavedIds>())).id as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(StunAgentSavedIds),
        "::",
        stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StunAgentSavedIds>())).method as *const _ as usize },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(StunAgentSavedIds),
        "::",
        stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StunAgentSavedIds>())).key as *const _ as usize },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(StunAgentSavedIds),
        "::",
        stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StunAgentSavedIds>())).key_len as *const _ as usize },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(StunAgentSavedIds),
        "::",
        stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StunAgentSavedIds>())).long_term_key as *const _ as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(StunAgentSavedIds),
        "::",
        stringify!(long_term_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<StunAgentSavedIds>())).long_term_valid as *const _ as usize
        },
        56usize,
        concat!(
        "Offset of field: ",
        stringify!(StunAgentSavedIds),
        "::",
        stringify!(long_term_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StunAgentSavedIds>())).valid as *const _ as usize },
        57usize,
        concat!(
        "Offset of field: ",
        stringify!(StunAgentSavedIds),
        "::",
        stringify!(valid)
        )
    );
}
#[repr(C)]
pub struct stun_agent_t {
    pub compatibility: StunCompatibility,
    pub sent_ids: [StunAgentSavedIds; 200usize],
    pub known_attributes: *mut u16,
    pub usage_flags: StunAgentUsageFlags,
    pub software_attribute: *const ::std::os::raw::c_char,
    pub ms_ice2_send_legacy_connchecks: bool,
}
#[test]
fn bindgen_test_layout_stun_agent_t() {
    assert_eq!(
        ::std::mem::size_of::<stun_agent_t>(),
        12840usize,
        concat!("Size of: ", stringify!(stun_agent_t))
    );
    assert_eq!(
        ::std::mem::align_of::<stun_agent_t>(),
        8usize,
        concat!("Alignment of ", stringify!(stun_agent_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stun_agent_t>())).compatibility as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(stun_agent_t),
        "::",
        stringify!(compatibility)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stun_agent_t>())).sent_ids as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(stun_agent_t),
        "::",
        stringify!(sent_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stun_agent_t>())).known_attributes as *const _ as usize },
        12808usize,
        concat!(
        "Offset of field: ",
        stringify!(stun_agent_t),
        "::",
        stringify!(known_attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stun_agent_t>())).usage_flags as *const _ as usize },
        12816usize,
        concat!(
        "Offset of field: ",
        stringify!(stun_agent_t),
        "::",
        stringify!(usage_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stun_agent_t>())).software_attribute as *const _ as usize },
        12824usize,
        concat!(
        "Offset of field: ",
        stringify!(stun_agent_t),
        "::",
        stringify!(software_attribute)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stun_agent_t>())).ms_ice2_send_legacy_connchecks as *const _
                as usize
        },
        12832usize,
        concat!(
        "Offset of field: ",
        stringify!(stun_agent_t),
        "::",
        stringify!(ms_ice2_send_legacy_connchecks)
        )
    );
}
#[doc = " StunDefaultValidaterData:"]
#[doc = " @username: The username"]
#[doc = " @username_len: The length of the @username"]
#[doc = " @password: The password"]
#[doc = " @password_len: The length of the @password"]
#[doc = ""]
#[doc = " This structure is used as an element of the user_data to the"]
#[doc = " stun_agent_default_validater() function for authenticating a STUN"]
#[doc = " message during validationg."]
#[doc = " <para> See also: stun_agent_default_validater() </para>"]
#[repr(C)]
pub struct StunDefaultValidaterData {
    pub username: *mut u8,
    pub username_len: size_t,
    pub password: *mut u8,
    pub password_len: size_t,
}
#[test]
fn bindgen_test_layout_StunDefaultValidaterData() {
    assert_eq!(
        ::std::mem::size_of::<StunDefaultValidaterData>(),
        32usize,
        concat!("Size of: ", stringify!(StunDefaultValidaterData))
    );
    assert_eq!(
        ::std::mem::align_of::<StunDefaultValidaterData>(),
        8usize,
        concat!("Alignment of ", stringify!(StunDefaultValidaterData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<StunDefaultValidaterData>())).username as *const _ as usize
        },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(StunDefaultValidaterData),
        "::",
        stringify!(username)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<StunDefaultValidaterData>())).username_len as *const _ as usize
        },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(StunDefaultValidaterData),
        "::",
        stringify!(username_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<StunDefaultValidaterData>())).password as *const _ as usize
        },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(StunDefaultValidaterData),
        "::",
        stringify!(password)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<StunDefaultValidaterData>())).password_len as *const _ as usize
        },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(StunDefaultValidaterData),
        "::",
        stringify!(password_len)
        )
    );
}
#[doc = " StunMessageIntegrityValidate:"]
#[doc = " @agent: The #StunAgent"]
#[doc = " @message: The #StunMessage being validated"]
#[doc = " @username: The username found in the @message"]
#[doc = " @username_len: The length of @username"]
#[doc = " @password: The password associated with that username. This argument is a"]
#[doc = " pointer to a byte array that must be set by the validater function."]
#[doc = " @password_len: The length of @password which must also be set by the"]
#[doc = " validater function."]
#[doc = " @user_data: Data to give the function"]
#[doc = ""]
#[doc = " This is the prototype for the @validater argument of the stun_agent_validate()"]
#[doc = " function."]
#[doc = " <para> See also: stun_agent_validate() </para>"]
#[doc = " Returns: %TRUE if the authentication was successful,"]
#[doc = " %FALSE if the authentication failed"]
pub type StunMessageIntegrityValidate = ::std::option::Option<
    unsafe extern "C" fn(
        agent: *mut StunAgent,
        message: *mut StunMessage,
        username: *mut u8,
        username_len: u16,
        password: *mut *mut u8,
        password_len: *mut size_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = " stun_agent_default_validater:"]
    #[doc = " @agent: The #StunAgent"]
    #[doc = " @message: The #StunMessage being validated"]
    #[doc = " @username: The username found in the @message"]
    #[doc = " @username_len: The length of @username"]
    #[doc = " @password: The password associated with that username. This argument is a"]
    #[doc = " pointer to a byte array that must be set by the validater function."]
    #[doc = " @password_len: The length of @password which must also be set by the"]
    #[doc = " validater function."]
    #[doc = " @user_data: This must be an array of #StunDefaultValidaterData structures."]
    #[doc = " The last element in the array must have a username set to NULL"]
    #[doc = ""]
    #[doc = " This is a helper function to be used with stun_agent_validate(). If no"]
    #[doc = " complicated processing of the username needs to be done, this function can"]
    #[doc = " be used with stun_agent_validate() to quickly and easily match the username"]
    #[doc = " of a STUN message with its password. Its @user_data argument must be an array"]
    #[doc = " of #StunDefaultValidaterData which will allow us to map a username to a"]
    #[doc = " password"]
    #[doc = " <para> See also: stun_agent_validate() </para>"]
    #[doc = " Returns: %TRUE if the authentication was successful,"]
    #[doc = " %FALSE if the authentication failed"]
    pub fn stun_agent_default_validater(
        agent: *mut StunAgent,
        message: *mut StunMessage,
        username: *mut u8,
        username_len: u16,
        password: *mut *mut u8,
        password_len: *mut size_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " stun_agent_init:"]
    #[doc = " @agent: The #StunAgent to initialize"]
    #[doc = " @known_attributes: An array of #uint16_t specifying which attributes should"]
    #[doc = " be known by the agent. Any STUN message received that contains a mandatory"]
    #[doc = " attribute that is not in this array will yield a"]
    #[doc = " #STUN_VALIDATION_UNKNOWN_REQUEST_ATTRIBUTE or a"]
    #[doc = " #STUN_VALIDATION_UNKNOWN_ATTRIBUTE error when calling stun_agent_validate()"]
    #[doc = " @compatibility: The #StunCompatibility to use for this agent. This will affect"]
    #[doc = " how the agent builds and validates the STUN messages"]
    #[doc = " @usage_flags: A bitflag using #StunAgentUsageFlags values to define which"]
    #[doc = " STUN usages the agent should use."]
    #[doc = ""]
    #[doc = " This function must be called to initialize an agent before it is being used."]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "The @known_attributes data must exist in memory as long as the @agent is used"]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "If the #STUN_AGENT_USAGE_SHORT_TERM_CREDENTIALS and"]
    #[doc = "#STUN_AGENT_USAGE_LONG_TERM_CREDENTIALS usage flags are not set, then the"]
    #[doc = "agent will default in using the short term credentials mechanism"]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "The #STUN_AGENT_USAGE_USE_FINGERPRINT and #STUN_AGENT_USAGE_ADD_SOFTWARE"]
    #[doc = "usage flags are only valid if the #STUN_COMPATIBILITY_RFC5389 or"]
    #[doc = "#STUN_COMPATIBILITY_MSICE2 @compatibility is used"]
    #[doc = "</para>"]
    #[doc = "</note>"]
    pub fn stun_agent_init(
        agent: *mut StunAgent,
        known_attributes: *const u16,
        compatibility: StunCompatibility,
        usage_flags: StunAgentUsageFlags,
    );
}
extern "C" {
    #[doc = " stun_agent_validate:"]
    #[doc = " @agent: The #StunAgent"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buffer: The data buffer of the STUN message"]
    #[doc = " @buffer_len: The length of @buffer"]
    #[doc = " @validater: A #StunMessageIntegrityValidate function callback that will"]
    #[doc = " be called if the agent needs to validate a MESSAGE-INTEGRITY attribute. It"]
    #[doc = " will only be called if the agent finds a message that needs authentication"]
    #[doc = " and a USERNAME is present in the STUN message, but no password is known."]
    #[doc = " The validater will not be called if the #STUN_AGENT_USAGE_IGNORE_CREDENTIALS"]
    #[doc = " usage flag is set on the agent, and it will always be called if the"]
    #[doc = " #STUN_AGENT_USAGE_FORCE_VALIDATER usage flag is set on the agent."]
    #[doc = " @validater_data: A user data to give to the @validater callback when it gets"]
    #[doc = " called."]
    #[doc = ""]
    #[doc = " This function is used to validate an inbound STUN message and transform its"]
    #[doc = " data buffer into a #StunMessage. It will take care of various validation"]
    #[doc = " algorithms to make sure that the STUN message is valid and correctly"]
    #[doc = " authenticated."]
    #[doc = " <para> See also: stun_agent_default_validater() </para>"]
    #[doc = " Returns: A #StunValidationStatus"]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "if the return value is different from #STUN_VALIDATION_NOT_STUN or"]
    #[doc = "#STUN_VALIDATION_INCOMPLETE_STUN, then the @msg argument will contain a valid"]
    #[doc = "STUN message that can be used."]
    #[doc = "This means that you can use the @msg variable as the @request argument to"]
    #[doc = "functions like stun_agent_init_error() or"]
    #[doc = "stun_agent_build_unknown_attributes_error()."]
    #[doc = "If the return value is #STUN_VALIDATION_BAD_REQUEST,"]
    #[doc = "#STUN_VALIDATION_UNAUTHORIZED or #STUN_VALIDATION_UNAUTHORIZED_BAD_REQUEST"]
    #[doc = "then the @key in the #StunMessage will not be set, so that error responses"]
    #[doc = "will not have a MESSAGE-INTEGRITY attribute."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    pub fn stun_agent_validate(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buffer: *const u8,
        buffer_len: size_t,
        validater: StunMessageIntegrityValidate,
        validater_data: *mut ::std::os::raw::c_void,
    ) -> StunValidationStatus;
}
extern "C" {
    #[doc = " stun_agent_init_request:"]
    #[doc = " @agent: The #StunAgent"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buffer: The buffer to use in the #StunMessage"]
    #[doc = " @buffer_len: The length of the buffer"]
    #[doc = " @m: The #StunMethod of the request"]
    #[doc = ""]
    #[doc = " Creates a new STUN message of class #STUN_REQUEST and with the method @m"]
    #[doc = " Returns: %TRUE if the message was initialized correctly, %FALSE otherwise"]
    pub fn stun_agent_init_request(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buffer: *mut u8,
        buffer_len: size_t,
        m: StunMethod,
    ) -> bool;
}
extern "C" {
    #[doc = " stun_agent_init_indication:"]
    #[doc = " @agent: The #StunAgent"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buffer: The buffer to use in the #StunMessage"]
    #[doc = " @buffer_len: The length of the buffer"]
    #[doc = " @m: The #StunMethod of the indication"]
    #[doc = ""]
    #[doc = " Creates a new STUN message of class #STUN_INDICATION and with the method @m"]
    #[doc = " Returns: %TRUE if the message was initialized correctly, %FALSE otherwise"]
    pub fn stun_agent_init_indication(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buffer: *mut u8,
        buffer_len: size_t,
        m: StunMethod,
    ) -> bool;
}
extern "C" {
    #[doc = " stun_agent_init_response:"]
    #[doc = " @agent: The #StunAgent"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buffer: The buffer to use in the #StunMessage"]
    #[doc = " @buffer_len: The length of the buffer"]
    #[doc = " @request: The #StunMessage of class #STUN_REQUEST that this response is for"]
    #[doc = ""]
    #[doc = " Creates a new STUN message of class #STUN_RESPONSE and with the same method"]
    #[doc = " and transaction ID as the message @request. This will also copy the pointer"]
    #[doc = " to the key that was used to authenticate the request, so you won't need to"]
    #[doc = " specify the key with stun_agent_finish_message()"]
    #[doc = " Returns: %TRUE if the message was initialized correctly, %FALSE otherwise"]
    pub fn stun_agent_init_response(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buffer: *mut u8,
        buffer_len: size_t,
        request: *const StunMessage,
    ) -> bool;
}
extern "C" {
    #[doc = " stun_agent_init_error:"]
    #[doc = " @agent: The #StunAgent"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buffer: The buffer to use in the #StunMessage"]
    #[doc = " @buffer_len: The length of the buffer"]
    #[doc = " @request: The #StunMessage of class #STUN_REQUEST that this error response"]
    #[doc = " is for"]
    #[doc = " @err: The #StunError to put in the ERROR-CODE attribute of the error response"]
    #[doc = ""]
    #[doc = " Creates a new STUN message of class #STUN_ERROR and with the same method"]
    #[doc = " and transaction ID as the message @request. This will also copy the pointer"]
    #[doc = " to the key that was used to authenticate the request (if authenticated),"]
    #[doc = " so you won't need to specify the key with stun_agent_finish_message()."]
    #[doc = " It will then add the ERROR-CODE attribute with code @err and the associated"]
    #[doc = " string."]
    #[doc = " Returns: %TRUE if the message was initialized correctly, %FALSE otherwise"]
    pub fn stun_agent_init_error(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buffer: *mut u8,
        buffer_len: size_t,
        request: *const StunMessage,
        err: StunError,
    ) -> bool;
}
extern "C" {
    #[doc = " stun_agent_build_unknown_attributes_error:"]
    #[doc = " @agent: The #StunAgent"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buffer: The buffer to use in the #StunMessage"]
    #[doc = " @buffer_len: The length of the buffer"]
    #[doc = " @request: The #StunMessage of class #STUN_REQUEST that this response is for"]
    #[doc = ""]
    #[doc = " Creates a new STUN message of class #STUN_ERROR and with the same method"]
    #[doc = " and transaction ID as the message @request.  It will then add the ERROR-CODE"]
    #[doc = " attribute with code #STUN_ERROR_UNKNOWN_ATTRIBUTE and add all the unknown"]
    #[doc = " mandatory attributes from the @request STUN message in the"]
    #[doc = " #STUN_ATTRIBUTE_UNKNOWN_ATTRIBUTES attribute, it will then finish the message"]
    #[doc = " by calling stun_agent_finish_message()"]
    #[doc = " Returns: The size of the message built"]
    pub fn stun_agent_build_unknown_attributes_error(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buffer: *mut u8,
        buffer_len: size_t,
        request: *const StunMessage,
    ) -> size_t;
}
extern "C" {
    #[doc = " stun_agent_finish_message:"]
    #[doc = " @agent: The #StunAgent"]
    #[doc = " @msg: The #StunMessage to finish"]
    #[doc = " @key: The key to use for the MESSAGE-INTEGRITY attribute"]
    #[doc = " @key_len: The length of the @key"]
    #[doc = ""]
    #[doc = " This function will 'finish' a message and make it ready to be sent. It will"]
    #[doc = " add the MESSAGE-INTEGRITY and FINGERPRINT attributes if necessary. If the"]
    #[doc = " STUN message has a #STUN_REQUEST class, it will save the transaction id of"]
    #[doc = " the message in the agent for future matching of the response."]
    #[doc = " <para>See also: stun_agent_forget_transaction()</para>"]
    #[doc = " Returns: The final size of the message built or 0 if an error occured"]
    #[doc = " <note>"]
    #[doc = "<para>"]
    #[doc = "The return value must always be checked. a value of 0 means the either"]
    #[doc = "the buffer's size is too small to contain the finishing attributes"]
    #[doc = "(MESSAGE-INTEGRITY, FINGERPRINT), or that there is no more free slots"]
    #[doc = "for saving the sent id in the agent's state."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "Everytime stun_agent_finish_message() is called for a #STUN_REQUEST"]
    #[doc = "message, you must make sure to call stun_agent_forget_transaction() in"]
    #[doc = "case the response times out and is never received. This is to avoid"]
    #[doc = "filling up the #StunAgent's sent ids state preventing any further"]
    #[doc = "use of the stun_agent_finish_message()"]
    #[doc = "</para>"]
    #[doc = "</note>"]
    pub fn stun_agent_finish_message(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        key: *const u8,
        key_len: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " stun_agent_forget_transaction:"]
    #[doc = " @agent: The #StunAgent"]
    #[doc = " @id: The #StunTransactionId of the transaction to forget"]
    #[doc = ""]
    #[doc = " This function is used to make the #StunAgent forget about a previously"]
    #[doc = " created transaction."]
    #[doc = " <para>"]
    #[doc = " This function should be called when a STUN request was previously"]
    #[doc = " created with stun_agent_finish_message() and for which no response was ever"]
    #[doc = " received (timed out). The #StunAgent keeps a list of the sent transactions"]
    #[doc = " in order to validate the responses received. If the response is never received"]
    #[doc = " this will allow the #StunAgent to forget about the timed out transaction and"]
    #[doc = " free its slot for future transactions."]
    #[doc = " </para>"]
    #[doc = " Since: 0.0.6"]
    #[doc = " Returns: %TRUE if the transaction was found, %FALSE otherwise"]
    pub fn stun_agent_forget_transaction(agent: *mut StunAgent, id: *mut u8) -> bool;
}
extern "C" {
    #[doc = " stun_agent_set_software:"]
    #[doc = " @agent: The #StunAgent"]
    #[doc = " @software: The value of the SOFTWARE attribute to add."]
    #[doc = ""]
    #[doc = " This function will set the value of the SOFTWARE attribute to be added to"]
    #[doc = " STUN requests, responses and error responses."]
    #[doc = " <para>"]
    #[doc = " Calling this function will automatically enable the addition of the SOFTWARE"]
    #[doc = " attribute for RFC5389 and MSICE2 compatibility modes."]
    #[doc = ""]
    #[doc = " </para>"]
    #[doc = " <note>"]
    #[doc = "<para>"]
    #[doc = "The @software argument must be in UTF-8 encoding and only the first"]
    #[doc = "128 characters will be sent."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "The value of the @software argument must stay valid throughout the life of"]
    #[doc = "the StunAgent's life. Do not free its content."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Since: 0.0.10"]
    #[doc = ""]
    pub fn stun_agent_set_software(agent: *mut StunAgent, software: *const ::std::os::raw::c_char);
}
pub const StunUsageBindReturn_STUN_USAGE_BIND_RETURN_SUCCESS: StunUsageBindReturn = 0;
pub const StunUsageBindReturn_STUN_USAGE_BIND_RETURN_ERROR: StunUsageBindReturn = 1;
pub const StunUsageBindReturn_STUN_USAGE_BIND_RETURN_INVALID: StunUsageBindReturn = 2;
pub const StunUsageBindReturn_STUN_USAGE_BIND_RETURN_ALTERNATE_SERVER: StunUsageBindReturn = 3;
pub const StunUsageBindReturn_STUN_USAGE_BIND_RETURN_TIMEOUT: StunUsageBindReturn = 4;
#[doc = " StunUsageBindReturn:"]
#[doc = " @STUN_USAGE_BIND_RETURN_SUCCESS: The binding usage succeeded"]
#[doc = " @STUN_USAGE_BIND_RETURN_ERROR: There was an unknown error in the bind usage"]
#[doc = " @STUN_USAGE_BIND_RETURN_INVALID: The message is invalid and should be ignored"]
#[doc = " @STUN_USAGE_BIND_RETURN_ALTERNATE_SERVER: The binding request has an"]
#[doc = " ALTERNATE-SERVER attribute"]
#[doc = " @STUN_USAGE_BIND_RETURN_TIMEOUT: The binding was unsuccessful because it has"]
#[doc = " timed out."]
#[doc = ""]
#[doc = " Return value of stun_usage_bind_process() and stun_usage_bind_run() which"]
#[doc = " allows you to see what status the function call returned."]
pub type StunUsageBindReturn = i32;
extern "C" {
    #[doc = " stun_usage_bind_create:"]
    #[doc = " @agent: The #StunAgent to use to create the binding request"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buffer: The buffer to use for creating the #StunMessage"]
    #[doc = " @buffer_len: The size of the @buffer"]
    #[doc = ""]
    #[doc = " Create a new STUN binding request to use with a STUN server."]
    #[doc = " Returns: The length of the built message."]
    pub fn stun_usage_bind_create(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buffer: *mut u8,
        buffer_len: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " stun_usage_bind_process:"]
    #[doc = " @msg: The #StunMessage to process"]
    #[doc = " @addr: A pointer to a #sockaddr structure to fill with the mapped address"]
    #[doc = " that the STUN server gives us"]
    #[doc = " @addrlen: The length of @add. rMust be set to the size of the @addr socket"]
    #[doc = " address and will be set to the actual length of the socket address."]
    #[doc = " @alternate_server: A pointer to a #sockaddr structure to fill with the"]
    #[doc = " address of an alternate server to which we should send our new STUN"]
    #[doc = " binding request, in case the currently used STUN server is requesting the use"]
    #[doc = " of an alternate server. This argument will only be filled if the return value"]
    #[doc = " of the function is #STUN_USAGE_BIND_RETURN_ALTERNATE_SERVER"]
    #[doc = " @alternate_server_len: The length of @alternate_server. Must be set to"]
    #[doc = " the size of the @alternate_server socket address and will be set to the"]
    #[doc = " actual length of the socket address."]
    #[doc = ""]
    #[doc = " Process a STUN binding response and extracts the mapped address from the STUN"]
    #[doc = " message. Also checks for the ALTERNATE-SERVER attribute."]
    #[doc = " Returns: A #StunUsageBindReturn value."]
    #[doc = " Note that #STUN_USAGE_BIND_RETURN_TIMEOUT cannot be returned by this function"]
    pub fn stun_usage_bind_process(
        msg: *mut StunMessage,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
        alternate_server: *mut sockaddr,
        alternate_server_len: *mut socklen_t,
    ) -> StunUsageBindReturn;
}
extern "C" {
    #[doc = " stun_usage_bind_keepalive:"]
    #[doc = " @agent: The #StunAgent to use to build the message"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buf: The buffer to use for creating the #StunMessage"]
    #[doc = " @len: The size of the @buf"]
    #[doc = ""]
    #[doc = " Creates a STUN binding indication that can be used for a keepalive."]
    #[doc = " Since this is an indication message, no STUN response will be generated"]
    #[doc = " and it can only be used as a keepalive message."]
    #[doc = " Returns: The length of the message to send"]
    pub fn stun_usage_bind_keepalive(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buf: *mut u8,
        len: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " stun_usage_bind_run:"]
    #[doc = " @srv: A pointer to the #sockaddr structure representing the STUN server's"]
    #[doc = " address"]
    #[doc = " @srvlen: The length of @srv"]
    #[doc = " @addr: A pointer to a #sockaddr structure to fill with the mapped address"]
    #[doc = " that the STUN server gives us"]
    #[doc = " @addrlen: The length of @addr"]
    #[doc = ""]
    #[doc = " This is a convenience function that will do a synchronous Binding request to"]
    #[doc = " a server and wait for its answer. It will create the socket transports and"]
    #[doc = " use the #StunTimer usage to send the request and handle the response."]
    #[doc = " Returns: A #StunUsageBindReturn."]
    #[doc = " Possible return values are #STUN_USAGE_BIND_RETURN_SUCCESS,"]
    #[doc = " #STUN_USAGE_BIND_RETURN_ERROR and #STUN_USAGE_BIND_RETURN_TIMEOUT"]
    pub fn stun_usage_bind_run(
        srv: *const sockaddr,
        srvlen: socklen_t,
        addr: *mut sockaddr_storage,
        addrlen: *mut socklen_t,
    ) -> StunUsageBindReturn;
}
pub const StunUsageIceCompatibility_STUN_USAGE_ICE_COMPATIBILITY_RFC5245:
StunUsageIceCompatibility = 0;
pub const StunUsageIceCompatibility_STUN_USAGE_ICE_COMPATIBILITY_GOOGLE: StunUsageIceCompatibility =
    1;
pub const StunUsageIceCompatibility_STUN_USAGE_ICE_COMPATIBILITY_MSN: StunUsageIceCompatibility = 2;
pub const StunUsageIceCompatibility_STUN_USAGE_ICE_COMPATIBILITY_MSICE2: StunUsageIceCompatibility =
    3;
pub const StunUsageIceCompatibility_STUN_USAGE_ICE_COMPATIBILITY_DRAFT19:
StunUsageIceCompatibility = 0;
pub const StunUsageIceCompatibility_STUN_USAGE_ICE_COMPATIBILITY_WLM2009:
StunUsageIceCompatibility = 3;
#[doc = " StunUsageIceCompatibility:"]
#[doc = " @STUN_USAGE_ICE_COMPATIBILITY_RFC5245: The ICE compatibility with RFC 5245"]
#[doc = " @STUN_USAGE_ICE_COMPATIBILITY_GOOGLE: The ICE compatibility with Google's"]
#[doc = " implementation of ICE"]
#[doc = " @STUN_USAGE_ICE_COMPATIBILITY_MSN: The ICE compatibility with MSN's"]
#[doc = " implementation of ICE"]
#[doc = " @STUN_USAGE_ICE_COMPATIBILITY_MSICE2: The ICE compatibility with [MS-ICE2]"]
#[doc = " specification"]
#[doc = " @STUN_USAGE_ICE_COMPATIBILITY_DRAFT19: The ICE compatibility with draft 19"]
#[doc = " @STUN_USAGE_ICE_COMPATIBILITY_WLM2009: An alias"]
#[doc = " for @STUN_USAGE_ICE_COMPATIBILITY_MSICE2"]
#[doc = ""]
#[doc = " This enum defines which compatibility modes this ICE usage can use"]
#[doc = ""]
#[doc = " <warning>@STUN_USAGE_ICE_COMPATIBILITY_DRAFT19 and"]
#[doc = " @STUN_USAGE_ICE_COMPATIBILITY_WLM2009 are deprecated and should not be used"]
#[doc = " in newly-written code. They are kept for compatibility reasons and represent"]
#[doc = " the same compatibilities as @STUN_USAGE_ICE_COMPATIBILITY_RFC5245 and"]
#[doc = " @STUN_USAGE_ICE_COMPATIBILITY_MSICE2 respectively.</warning>"]
pub type StunUsageIceCompatibility = i32;
pub const StunUsageIceReturn_STUN_USAGE_ICE_RETURN_SUCCESS: StunUsageIceReturn = 0;
pub const StunUsageIceReturn_STUN_USAGE_ICE_RETURN_ERROR: StunUsageIceReturn = 1;
pub const StunUsageIceReturn_STUN_USAGE_ICE_RETURN_INVALID: StunUsageIceReturn = 2;
pub const StunUsageIceReturn_STUN_USAGE_ICE_RETURN_ROLE_CONFLICT: StunUsageIceReturn = 3;
pub const StunUsageIceReturn_STUN_USAGE_ICE_RETURN_INVALID_REQUEST: StunUsageIceReturn = 4;
pub const StunUsageIceReturn_STUN_USAGE_ICE_RETURN_INVALID_METHOD: StunUsageIceReturn = 5;
pub const StunUsageIceReturn_STUN_USAGE_ICE_RETURN_MEMORY_ERROR: StunUsageIceReturn = 6;
pub const StunUsageIceReturn_STUN_USAGE_ICE_RETURN_INVALID_ADDRESS: StunUsageIceReturn = 7;
pub const StunUsageIceReturn_STUN_USAGE_ICE_RETURN_NO_MAPPED_ADDRESS: StunUsageIceReturn = 8;
#[doc = " StunUsageIceReturn:"]
#[doc = " @STUN_USAGE_ICE_RETURN_SUCCESS: The function succeeded"]
#[doc = " @STUN_USAGE_ICE_RETURN_ERROR: There was an unspecified error"]
#[doc = " @STUN_USAGE_ICE_RETURN_INVALID: The message is invalid for processing"]
#[doc = " @STUN_USAGE_ICE_RETURN_ROLE_CONFLICT: A role conflict was detected"]
#[doc = " @STUN_USAGE_ICE_RETURN_INVALID_REQUEST: The message is an not a request"]
#[doc = " @STUN_USAGE_ICE_RETURN_INVALID_METHOD: The method of the request is invalid"]
#[doc = " @STUN_USAGE_ICE_RETURN_MEMORY_ERROR: The buffer size is too small to hold"]
#[doc = " the STUN reply"]
#[doc = " @STUN_USAGE_ICE_RETURN_INVALID_ADDRESS: The mapped address argument has"]
#[doc = " an invalid address family"]
#[doc = " @STUN_USAGE_ICE_RETURN_NO_MAPPED_ADDRESS: The response is valid but no"]
#[doc = " MAPPED-ADDRESS or XOR-MAPPED-ADDRESS attribute was found"]
#[doc = ""]
#[doc = " Return value of stun_usage_ice_conncheck_process() and"]
#[doc = " stun_usage_ice_conncheck_create_reply() which allows you to see what"]
#[doc = " status the function call returned."]
pub type StunUsageIceReturn = i32;
extern "C" {
    #[doc = " stun_usage_ice_conncheck_create:"]
    #[doc = " @agent: The #StunAgent to use to build the request"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buffer: The buffer to use for creating the #StunMessage"]
    #[doc = " @buffer_len: The size of the @buffer"]
    #[doc = " @username: The username to use in the request"]
    #[doc = " @username_len: The length of @username"]
    #[doc = " @password: The key to use for building the MESSAGE-INTEGRITY"]
    #[doc = " @password_len: The length of @password"]
    #[doc = " @cand_use: Set to %TRUE to append the USE-CANDIDATE flag to the request"]
    #[doc = " @controlling: Set to %TRUE if you are the controlling agent or set to"]
    #[doc = " %FALSE if you are the controlled agent."]
    #[doc = " @priority: The value of the PRIORITY attribute"]
    #[doc = " @tie: The value of the tie-breaker to put in the ICE-CONTROLLED or"]
    #[doc = " ICE-CONTROLLING attribute"]
    #[doc = " @candidate_identifier: The foundation value to put in the"]
    #[doc = " CANDIDATE-IDENTIFIER attribute"]
    #[doc = " @compatibility: The compatibility mode to use for building the conncheck"]
    #[doc = " request"]
    #[doc = ""]
    #[doc = " Builds an ICE connectivity check STUN message."]
    #[doc = " If the compatibility is not #STUN_USAGE_ICE_COMPATIBILITY_RFC5245, the"]
    #[doc = " @cand_use, @controlling, @priority and @tie arguments are not used."]
    #[doc = " If the compatibility is not #STUN_USAGE_ICE_COMPATIBILITY_MSICE2, the"]
    #[doc = " @candidate_identifier argument is not used."]
    #[doc = " Returns: The length of the message built."]
    pub fn stun_usage_ice_conncheck_create(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buffer: *mut u8,
        buffer_len: size_t,
        username: *const u8,
        username_len: size_t,
        password: *const u8,
        password_len: size_t,
        cand_use: bool,
        controlling: bool,
        priority: u32,
        tie: u64,
        candidate_identifier: *const ::std::os::raw::c_char,
        compatibility: StunUsageIceCompatibility,
    ) -> size_t;
}
extern "C" {
    #[doc = " stun_usage_ice_conncheck_process:"]
    #[doc = " @msg: The #StunMessage to process"]
    #[doc = " @addr: A pointer to a #sockaddr structure to fill with the mapped address"]
    #[doc = " that the STUN connectivity check response contains"]
    #[doc = " @addrlen: The length of @addr"]
    #[doc = " @compatibility: The compatibility mode to use for processing the conncheck"]
    #[doc = " response"]
    #[doc = ""]
    #[doc = " Process an ICE connectivity check STUN message and retrieve the"]
    #[doc = " mapped address from the message"]
    #[doc = " <para> See also stun_usage_ice_conncheck_priority() and"]
    #[doc = " stun_usage_ice_conncheck_use_candidate() </para>"]
    #[doc = " Returns: A #StunUsageIceReturn value"]
    pub fn stun_usage_ice_conncheck_process(
        msg: *mut StunMessage,
        addr: *mut sockaddr_storage,
        addrlen: *mut socklen_t,
        compatibility: StunUsageIceCompatibility,
    ) -> StunUsageIceReturn;
}
extern "C" {
    #[doc = " stun_usage_ice_conncheck_create_reply:"]
    #[doc = " @agent: The #StunAgent to use to build the response"]
    #[doc = " @req: The original STUN request to reply to"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buf: The buffer to use for creating the #StunMessage"]
    #[doc = " @plen: A pointer containing the size of the @buffer on input."]
    #[doc = " Will contain the length of the message built on output."]
    #[doc = " @src: A pointer to a #sockaddr structure containing the source address from"]
    #[doc = " which the request was received. Will be used as the mapped address in the"]
    #[doc = " response"]
    #[doc = " @srclen: The length of @addr"]
    #[doc = " @control: Set to %TRUE if you are the controlling agent or set to"]
    #[doc = " %FALSE if you are the controlled agent."]
    #[doc = " @tie: The value of the tie-breaker to put in the ICE-CONTROLLED or"]
    #[doc = " ICE-CONTROLLING attribute"]
    #[doc = " @compatibility: The compatibility mode to use for building the conncheck"]
    #[doc = " response"]
    #[doc = ""]
    #[doc = " Tries to parse a STUN connectivity check request and builds a"]
    #[doc = " response accordingly."]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "In case of error, the @msg is filled with the appropriate error response"]
    #[doc = "to be sent and the value of @plen is set to the size of that message."]
    #[doc = "If @plen has a size of 0, then no error response should be sent."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = " Returns: A #StunUsageIceReturn value"]
    pub fn stun_usage_ice_conncheck_create_reply(
        agent: *mut StunAgent,
        req: *mut StunMessage,
        msg: *mut StunMessage,
        buf: *mut u8,
        plen: *mut size_t,
        src: *const sockaddr_storage,
        srclen: socklen_t,
        control: *mut bool,
        tie: u64,
        compatibility: StunUsageIceCompatibility,
    ) -> StunUsageIceReturn;
}
extern "C" {
    #[doc = " stun_usage_ice_conncheck_priority:"]
    #[doc = " @msg: The #StunMessage to parse"]
    #[doc = ""]
    #[doc = " Extracts the priority from a STUN message."]
    #[doc = " Returns: host byte order priority, or 0 if not specified."]
    pub fn stun_usage_ice_conncheck_priority(msg: *const StunMessage) -> u32;
}
extern "C" {
    #[doc = " stun_usage_ice_conncheck_use_candidate:"]
    #[doc = " @msg: The #StunMessage to parse"]
    #[doc = ""]
    #[doc = " Extracts the USE-CANDIDATE attribute flag from a STUN message."]
    #[doc = " Returns: %TRUE if the flag is set, %FALSE if not."]
    pub fn stun_usage_ice_conncheck_use_candidate(msg: *const StunMessage) -> bool;
}
pub const StunUsageTurnRequestPorts_STUN_USAGE_TURN_REQUEST_PORT_NORMAL: StunUsageTurnRequestPorts =
    0;
pub const StunUsageTurnRequestPorts_STUN_USAGE_TURN_REQUEST_PORT_EVEN: StunUsageTurnRequestPorts =
    1;
pub const StunUsageTurnRequestPorts_STUN_USAGE_TURN_REQUEST_PORT_EVEN_AND_RESERVE:
StunUsageTurnRequestPorts = 2;
#[doc = " StunUsageTurnRequestPorts:"]
#[doc = " @STUN_USAGE_TURN_REQUEST_PORT_NORMAL: Request a normal port"]
#[doc = " @STUN_USAGE_TURN_REQUEST_PORT_EVEN: Request an even port"]
#[doc = " @STUN_USAGE_TURN_REQUEST_PORT_EVEN_AND_RESERVE: Request an even port and"]
#[doc = " reserve the next higher port"]
#[doc = ""]
#[doc = " This enum is used to specify which port configuration you want when creating"]
#[doc = " a new Allocation"]
pub type StunUsageTurnRequestPorts = i32;
pub const StunUsageTurnCompatibility_STUN_USAGE_TURN_COMPATIBILITY_DRAFT9:
StunUsageTurnCompatibility = 0;
pub const StunUsageTurnCompatibility_STUN_USAGE_TURN_COMPATIBILITY_GOOGLE:
StunUsageTurnCompatibility = 1;
pub const StunUsageTurnCompatibility_STUN_USAGE_TURN_COMPATIBILITY_MSN: StunUsageTurnCompatibility =
    2;
pub const StunUsageTurnCompatibility_STUN_USAGE_TURN_COMPATIBILITY_OC2007:
StunUsageTurnCompatibility = 3;
pub const StunUsageTurnCompatibility_STUN_USAGE_TURN_COMPATIBILITY_RFC5766:
StunUsageTurnCompatibility = 4;
#[doc = " StunUsageTurnCompatibility:"]
#[doc = " @STUN_USAGE_TURN_COMPATIBILITY_DRAFT9: Use the specification compatible with"]
#[doc = " TURN Draft 09"]
#[doc = " @STUN_USAGE_TURN_COMPATIBILITY_GOOGLE: Use the specification compatible with"]
#[doc = " Google Talk's relay server"]
#[doc = " @STUN_USAGE_TURN_COMPATIBILITY_MSN: Use the specification compatible with"]
#[doc = " MSN TURN servers"]
#[doc = " @STUN_USAGE_TURN_COMPATIBILITY_OC2007: Use the specification compatible with"]
#[doc = " Microsoft Office Communicator 2007"]
#[doc = " @STUN_USAGE_TURN_COMPATIBILITY_RFC5766: Use the specification compatible with"]
#[doc = " RFC 5766 (the final, canonical TURN standard)"]
#[doc = ""]
#[doc = " Specifies which TURN specification compatibility to use"]
pub type StunUsageTurnCompatibility = i32;
pub const StunUsageTurnReturn_STUN_USAGE_TURN_RETURN_RELAY_SUCCESS: StunUsageTurnReturn = 0;
pub const StunUsageTurnReturn_STUN_USAGE_TURN_RETURN_MAPPED_SUCCESS: StunUsageTurnReturn = 1;
pub const StunUsageTurnReturn_STUN_USAGE_TURN_RETURN_ERROR: StunUsageTurnReturn = 2;
pub const StunUsageTurnReturn_STUN_USAGE_TURN_RETURN_INVALID: StunUsageTurnReturn = 3;
pub const StunUsageTurnReturn_STUN_USAGE_TURN_RETURN_ALTERNATE_SERVER: StunUsageTurnReturn = 4;
#[doc = " StunUsageTurnReturn:"]
#[doc = " @STUN_USAGE_TURN_RETURN_RELAY_SUCCESS: The response was successful and a relay"]
#[doc = " address is provided"]
#[doc = " @STUN_USAGE_TURN_RETURN_MAPPED_SUCCESS: The response was successful and a"]
#[doc = " relay address as well as a mapped address are provided"]
#[doc = " @STUN_USAGE_TURN_RETURN_ERROR: The response resulted in an error"]
#[doc = " @STUN_USAGE_TURN_RETURN_INVALID: The response is not a valid response"]
#[doc = " @STUN_USAGE_TURN_RETURN_ALTERNATE_SERVER: The server requests the message"]
#[doc = " to be sent to an alternate server"]
#[doc = ""]
#[doc = " Return value of stun_usage_turn_process() and"]
#[doc = " stun_usage_turn_refresh_process() which allows you to see what status the"]
#[doc = " function call returned."]
pub type StunUsageTurnReturn = i32;
extern "C" {
    #[doc = " stun_usage_turn_create:"]
    #[doc = " @agent: The #StunAgent to use to build the request"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buffer: The buffer to use for creating the #StunMessage"]
    #[doc = " @buffer_len: The size of the @buffer"]
    #[doc = " @previous_response: If this is the first request you are sending, set this"]
    #[doc = " argument to NULL, if it's a subsequent request you are building, then set this"]
    #[doc = " argument to the response you have received. This argument is used for building"]
    #[doc = " long term credentials (using the REALM and NONCE attributes) as well as for"]
    #[doc = " getting the RESERVATION-TOKEN attribute when you previously requested an"]
    #[doc = " allocation which reserved two ports"]
    #[doc = " @request_ports: Specify how you want to request the allocated port(s)."]
    #[doc = " This is only used if the compatibility is set to"]
    #[doc = " #STUN_USAGE_TURN_COMPATIBILITY_DRAFT9"]
    #[doc = " <para>See #StunUsageTurnRequestPorts </para>"]
    #[doc = " @bandwidth: The bandwidth to request from the server for the allocation. If"]
    #[doc = " this value is negative, then no BANDWIDTH attribute is added to the request."]
    #[doc = " This is only used if the compatibility is set to"]
    #[doc = " #STUN_USAGE_TURN_COMPATIBILITY_DRAFT9"]
    #[doc = " @lifetime: The lifetime of the allocation to request from the server. If"]
    #[doc = " this value is negative, then no LIFETIME attribute is added to the request."]
    #[doc = " This is only used if the compatibility is set to"]
    #[doc = " #STUN_USAGE_TURN_COMPATIBILITY_DRAFT9"]
    #[doc = " @username: The username to use in the request"]
    #[doc = " @username_len: The length of @username"]
    #[doc = " @password: The key to use for building the MESSAGE-INTEGRITY"]
    #[doc = " @password_len: The length of @password"]
    #[doc = " @compatibility: The compatibility mode to use for building the Allocation"]
    #[doc = " request"]
    #[doc = ""]
    #[doc = " Create a new TURN Allocation request"]
    #[doc = " Returns: The length of the message to send"]
    pub fn stun_usage_turn_create(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buffer: *mut u8,
        buffer_len: size_t,
        previous_response: *mut StunMessage,
        request_ports: StunUsageTurnRequestPorts,
        bandwidth: i32,
        lifetime: i32,
        username: *mut u8,
        username_len: size_t,
        password: *mut u8,
        password_len: size_t,
        compatibility: StunUsageTurnCompatibility,
    ) -> size_t;
}
extern "C" {
    #[doc = " stun_usage_turn_create_refresh:"]
    #[doc = " @agent: The #StunAgent to use to build the request"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buffer: The buffer to use for creating the #StunMessage"]
    #[doc = " @buffer_len: The size of the @buffer"]
    #[doc = " @previous_response: If this is the first request you are sending, set this"]
    #[doc = " argument to NULL, if it's a subsequent request you are building, then set this"]
    #[doc = " argument to the response you have received. This argument is used for building"]
    #[doc = " long term credentials (using the REALM and NONCE attributes)"]
    #[doc = " @lifetime: The lifetime of the allocation to request from the server. If"]
    #[doc = " this value is negative, then no LIFETIME attribute is added to the request."]
    #[doc = " This is only used if the compatibility is set to"]
    #[doc = " #STUN_USAGE_TURN_COMPATIBILITY_DRAFT9"]
    #[doc = " @username: The username to use in the request"]
    #[doc = " @username_len: The length of @username"]
    #[doc = " @password: The key to use for building the MESSAGE-INTEGRITY"]
    #[doc = " @password_len: The length of @password"]
    #[doc = " @compatibility: The compatibility mode to use for building the Allocation"]
    #[doc = " request"]
    #[doc = ""]
    #[doc = " Create a new TURN Refresh request"]
    #[doc = " Returns: The length of the message to send"]
    pub fn stun_usage_turn_create_refresh(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buffer: *mut u8,
        buffer_len: size_t,
        previous_response: *mut StunMessage,
        lifetime: i32,
        username: *mut u8,
        username_len: size_t,
        password: *mut u8,
        password_len: size_t,
        compatibility: StunUsageTurnCompatibility,
    ) -> size_t;
}
extern "C" {
    #[doc = " stun_usage_turn_create_permission:"]
    #[doc = " @agent: The #StunAgent to use to build the request"]
    #[doc = " @msg: The #StunMessage to build"]
    #[doc = " @buffer: The buffer to use for creating the #StunMessage"]
    #[doc = " @buffer_len: The size of the @buffer"]
    #[doc = " @username: The username to use in the request"]
    #[doc = " @username_len: The length of @username"]
    #[doc = " @password: The key to use for building the MESSAGE-INTEGRITY"]
    #[doc = " @password_len: The length of @password"]
    #[doc = " @realm: The realm identifier to use in the request"]
    #[doc = " @realm_len: The length of @realm"]
    #[doc = " @nonce: Unique and securely random nonce to use in the request"]
    #[doc = " @nonce_len: The length of @nonce"]
    #[doc = " @peer: Server-reflexive host address to request permission for"]
    #[doc = " @compatibility: The compatibility mode to use for building the"]
    #[doc = " CreatePermission request"]
    #[doc = ""]
    #[doc = " Create a new TURN CreatePermission request"]
    #[doc = ""]
    #[doc = " Returns: The length of the message to send"]
    pub fn stun_usage_turn_create_permission(
        agent: *mut StunAgent,
        msg: *mut StunMessage,
        buffer: *mut u8,
        buffer_len: size_t,
        username: *mut u8,
        username_len: size_t,
        password: *mut u8,
        password_len: size_t,
        realm: *mut u8,
        realm_len: size_t,
        nonce: *mut u8,
        nonce_len: size_t,
        peer: *mut sockaddr_storage,
        compatibility: StunUsageTurnCompatibility,
    ) -> size_t;
}
extern "C" {
    #[doc = " stun_usage_turn_process:"]
    #[doc = " @msg: The message containing the response"]
    #[doc = " @relay_addr: A pointer to a #sockaddr structure to fill with the relay address"]
    #[doc = " that the TURN server allocated for us"]
    #[doc = " @relay_addrlen: The length of @relay_addr"]
    #[doc = " @addr: A pointer to a #sockaddr structure to fill with the mapped address"]
    #[doc = " that the STUN response contains."]
    #[doc = " This argument will only be filled if the return value"]
    #[doc = " of the function is #STUN_USAGE_TURN_RETURN_MAPPED_SUCCESS"]
    #[doc = " @addrlen: The length of @addr"]
    #[doc = " @alternate_server: A pointer to a #sockaddr structure to fill with the"]
    #[doc = " address of an alternate server to which we should send our new STUN"]
    #[doc = " Allocate request, in case the currently used TURN server is requesting the use"]
    #[doc = " of an alternate server. This argument will only be filled if the return value"]
    #[doc = " of the function is #STUN_USAGE_TURN_RETURN_ALTERNATE_SERVER"]
    #[doc = " In the case of @STUN_USAGE_TURN_COMPATIBILITY_OC2007 compatibility, the"]
    #[doc = " @alternate_server could be filled at any time, and should only be considered"]
    #[doc = " if the request was sent to a different server than the address returned"]
    #[doc = " in the @alternate_server field"]
    #[doc = " @alternate_server_len: The length of @alternate_server"]
    #[doc = " @bandwidth: A pointer to fill with the bandwidth the TURN server allocated us"]
    #[doc = " @lifetime: A pointer to fill with the lifetime of the allocation"]
    #[doc = " @compatibility: The compatibility mode to use for processing the Allocation"]
    #[doc = " response"]
    #[doc = ""]
    #[doc = " Process a TURN Allocate response and extract the necessary information from"]
    #[doc = " the message"]
    #[doc = " Returns: A #StunUsageTurnReturn value"]
    pub fn stun_usage_turn_process(
        msg: *mut StunMessage,
        relay_addr: *mut sockaddr_storage,
        relay_addrlen: *mut socklen_t,
        addr: *mut sockaddr_storage,
        addrlen: *mut socklen_t,
        alternate_server: *mut sockaddr_storage,
        alternate_server_len: *mut socklen_t,
        bandwidth: *mut u32,
        lifetime: *mut u32,
        compatibility: StunUsageTurnCompatibility,
    ) -> StunUsageTurnReturn;
}
extern "C" {
    #[doc = " stun_usage_turn_refresh_process:"]
    #[doc = " @msg: The message containing the response"]
    #[doc = " @lifetime: A pointer to fill with the lifetime of the allocation"]
    #[doc = " @compatibility: The compatibility mode to use for processing the Refresh"]
    #[doc = " response"]
    #[doc = ""]
    #[doc = " Process a TURN Refresh response and extract the necessary information from"]
    #[doc = " the message"]
    #[doc = " Returns: A #StunUsageTurnReturn value. A #STUN_USAGE_TURN_RETURN_RELAY_SUCCESS"]
    #[doc = " means the Refresh was successful, but no relay address is given (kept the same"]
    #[doc = " as for the original allocation)"]
    pub fn stun_usage_turn_refresh_process(
        msg: *mut StunMessage,
        lifetime: *mut u32,
        compatibility: StunUsageTurnCompatibility,
    ) -> StunUsageTurnReturn;
}
#[doc = " StunTimer:"]
#[doc = ""]
#[doc = " An opaque structure representing a STUN transaction retransmission timer"]
pub type StunTimer = stun_timer_s;
#[repr(C)]
pub struct stun_timer_s {
    pub deadline: timeval,
    pub delay: ::std::os::raw::c_uint,
    pub retransmissions: ::std::os::raw::c_uint,
    pub max_retransmissions: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_stun_timer_s() {
    assert_eq!(
        ::std::mem::size_of::<stun_timer_s>(),
        20usize,
        concat!("Size of: ", stringify!(stun_timer_s))
    );
    assert_eq!(
        ::std::mem::align_of::<stun_timer_s>(),
        4usize,
        concat!("Alignment of ", stringify!(stun_timer_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stun_timer_s>())).deadline as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(stun_timer_s),
        "::",
        stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stun_timer_s>())).delay as *const _ as usize },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(stun_timer_s),
        "::",
        stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stun_timer_s>())).retransmissions as *const _ as usize },
        12usize,
        concat!(
        "Offset of field: ",
        stringify!(stun_timer_s),
        "::",
        stringify!(retransmissions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<stun_timer_s>())).max_retransmissions as *const _ as usize
        },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(stun_timer_s),
        "::",
        stringify!(max_retransmissions)
        )
    );
}
pub const StunUsageTimerReturn_STUN_USAGE_TIMER_RETURN_SUCCESS: StunUsageTimerReturn = 0;
pub const StunUsageTimerReturn_STUN_USAGE_TIMER_RETURN_RETRANSMIT: StunUsageTimerReturn = 1;
pub const StunUsageTimerReturn_STUN_USAGE_TIMER_RETURN_TIMEOUT: StunUsageTimerReturn = 2;
#[doc = " StunUsageTimerReturn:"]
#[doc = " @STUN_USAGE_TIMER_RETURN_SUCCESS: The timer was refreshed successfully"]
#[doc = " and there is nothing to be done"]
#[doc = " @STUN_USAGE_TIMER_RETURN_RETRANSMIT: The timer expired and the message"]
#[doc = " should be retransmitted now."]
#[doc = " @STUN_USAGE_TIMER_RETURN_TIMEOUT: The timer expired as well as all the"]
#[doc = " retransmissions, the transaction timed out"]
#[doc = ""]
#[doc = " Return value of stun_usage_timer_refresh() which provides you with status"]
#[doc = " information on the timer."]
pub type StunUsageTimerReturn = i32;
extern "C" {
    #[doc = " stun_timer_start:"]
    #[doc = " @timer: The #StunTimer to start"]
    #[doc = " @initial_timeout: The initial timeout to use before the first retransmission"]
    #[doc = " @max_retransmissions: The maximum number of transmissions before the"]
    #[doc = " #StunTimer times out"]
    #[doc = ""]
    #[doc = " Starts a STUN transaction retransmission timer."]
    #[doc = " This should be called as soon as you send the message for the first time on"]
    #[doc = " a UDP socket."]
    #[doc = " The timeout before the next retransmission is set to @initial_timeout, then"]
    #[doc = " each time a packet is retransmited, that timeout will be doubled, until the"]
    #[doc = " @max_retransmissions retransmissions limit is reached."]
    #[doc = " <para>"]
    #[doc = " To determine the total timeout value, one can use the following equation :"]
    #[doc = "<programlisting>"]
    #[doc = "total_timeout =  initial_timeout * (2^(max_retransmissions + 1) - 1);"]
    #[doc = "</programlisting>"]
    #[doc = " </para>"]
    #[doc = ""]
    #[doc = " See also: #STUN_TIMER_DEFAULT_TIMEOUT"]
    #[doc = ""]
    #[doc = " See also: #STUN_TIMER_DEFAULT_MAX_RETRANSMISSIONS"]
    pub fn stun_timer_start(
        timer: *mut StunTimer,
        initial_timeout: ::std::os::raw::c_uint,
        max_retransmissions: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " stun_timer_start_reliable:"]
    #[doc = " @timer: The #StunTimer to start"]
    #[doc = " @initial_timeout: The initial timeout to use before the first retransmission"]
    #[doc = ""]
    #[doc = " Starts a STUN transaction retransmission timer for a reliable transport."]
    #[doc = " This should be called as soon as you send the message for the first time on"]
    #[doc = " a TCP socket"]
    pub fn stun_timer_start_reliable(
        timer: *mut StunTimer,
        initial_timeout: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " stun_timer_refresh:"]
    #[doc = " @timer: The #StunTimer to refresh"]
    #[doc = ""]
    #[doc = " Updates a STUN transaction retransmission timer."]
    #[doc = " Returns: A #StunUsageTimerReturn telling you what to do next"]
    pub fn stun_timer_refresh(timer: *mut StunTimer) -> StunUsageTimerReturn;
}
extern "C" {
    #[doc = " stun_timer_remainder:"]
    #[doc = " @timer: The #StunTimer to query"]
    #[doc = ""]
    #[doc = " Query the timer on the time left before the next refresh should be done"]
    #[doc = " Returns: The time remaining for the timer to expire in milliseconds"]
    pub fn stun_timer_remainder(timer: *const StunTimer) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PseudoTcpSocket {
    _unused: [u8; 0],
}
#[doc = " PseudoTcpSocket:"]
#[doc = ""]
#[doc = " The #PseudoTcpSocket is the GObject implementing the Pseudo TCP Socket"]
#[doc = ""]
#[doc = " Since: 0.0.11"]
pub type PseudoTcpSocket = _PseudoTcpSocket;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PseudoTcpSocketClass {
    _unused: [u8; 0],
}
pub type PseudoTcpSocketClass = _PseudoTcpSocketClass;
extern "C" {
    pub fn pseudo_tcp_socket_get_type() -> GType;
}
pub const PseudoTcpDebugLevel_PSEUDO_TCP_DEBUG_NONE: PseudoTcpDebugLevel = 0;
pub const PseudoTcpDebugLevel_PSEUDO_TCP_DEBUG_NORMAL: PseudoTcpDebugLevel = 1;
pub const PseudoTcpDebugLevel_PSEUDO_TCP_DEBUG_VERBOSE: PseudoTcpDebugLevel = 2;
#[doc = " PseudoTcpDebugLevel:"]
#[doc = " @PSEUDO_TCP_DEBUG_NONE: Disable debug messages"]
#[doc = " @PSEUDO_TCP_DEBUG_NORMAL: Enable basic debug messages"]
#[doc = " @PSEUDO_TCP_DEBUG_VERBOSE: Enable verbose debug messages"]
#[doc = ""]
#[doc = " Valid values of debug levels to be set."]
#[doc = ""]
#[doc = " Since: 0.0.11"]
pub type PseudoTcpDebugLevel = i32;
pub const PseudoTcpState_PSEUDO_TCP_LISTEN: PseudoTcpState = 0;
pub const PseudoTcpState_PSEUDO_TCP_SYN_SENT: PseudoTcpState = 1;
pub const PseudoTcpState_PSEUDO_TCP_SYN_RECEIVED: PseudoTcpState = 2;
pub const PseudoTcpState_PSEUDO_TCP_ESTABLISHED: PseudoTcpState = 3;
pub const PseudoTcpState_PSEUDO_TCP_CLOSED: PseudoTcpState = 4;
pub const PseudoTcpState_PSEUDO_TCP_FIN_WAIT_1: PseudoTcpState = 5;
pub const PseudoTcpState_PSEUDO_TCP_FIN_WAIT_2: PseudoTcpState = 6;
pub const PseudoTcpState_PSEUDO_TCP_CLOSING: PseudoTcpState = 7;
pub const PseudoTcpState_PSEUDO_TCP_TIME_WAIT: PseudoTcpState = 8;
pub const PseudoTcpState_PSEUDO_TCP_CLOSE_WAIT: PseudoTcpState = 9;
pub const PseudoTcpState_PSEUDO_TCP_LAST_ACK: PseudoTcpState = 10;
#[doc = " PseudoTcpState:"]
#[doc = " @PSEUDO_TCP_LISTEN: The socket's initial state. The socket isn't connected and is"]
#[doc = " listening for an incoming connection"]
#[doc = " @PSEUDO_TCP_SYN_SENT: The socket has sent a connection request (SYN) packet and is"]
#[doc = " waiting for an answer"]
#[doc = " @PSEUDO_TCP_SYN_RECEIVED: The socket has received a connection request (SYN) packet."]
#[doc = " @PSEUDO_TCP_ESTABLISHED: The socket is connected"]
#[doc = " @PSEUDO_TCP_CLOSED: The socket has been closed"]
#[doc = " @PSEUDO_TCP_FIN_WAIT_1: The socket has been closed locally but not remotely"]
#[doc = " (Since: 0.1.8)"]
#[doc = " @PSEUDO_TCP_FIN_WAIT_2: The socket has been closed locally but not remotely"]
#[doc = " (Since: 0.1.8)"]
#[doc = " @PSEUDO_TCP_CLOSING: The socket has been closed locally and remotely"]
#[doc = " (Since: 0.1.8)"]
#[doc = " @PSEUDO_TCP_TIME_WAIT: The socket has been closed locally and remotely"]
#[doc = " (Since: 0.1.8)"]
#[doc = " @PSEUDO_TCP_CLOSE_WAIT: The socket has been closed remotely but not locally"]
#[doc = " (Since: 0.1.8)"]
#[doc = " @PSEUDO_TCP_LAST_ACK: The socket has been closed locally and remotely"]
#[doc = " (Since: 0.1.8)"]
#[doc = ""]
#[doc = " An enum representing the state of the #PseudoTcpSocket. These states"]
#[doc = " correspond to the TCP states in RFC 793."]
#[doc = " <para> See also: #PseudoTcpSocket:state </para>"]
#[doc = ""]
#[doc = " Since: 0.0.11"]
pub type PseudoTcpState = i32;
pub const PseudoTcpWriteResult_WR_SUCCESS: PseudoTcpWriteResult = 0;
pub const PseudoTcpWriteResult_WR_TOO_LARGE: PseudoTcpWriteResult = 1;
pub const PseudoTcpWriteResult_WR_FAIL: PseudoTcpWriteResult = 2;
#[doc = " PseudoTcpWriteResult:"]
#[doc = " @WR_SUCCESS: The write operation was successful"]
#[doc = " @WR_TOO_LARGE: The socket type requires that message be sent atomically"]
#[doc = " and the size of the message to be sent made this impossible."]
#[doc = " @WR_FAIL: There was an error sending the message"]
#[doc = ""]
#[doc = " An enum representing the result value of the write operation requested by"]
#[doc = " the #PseudoTcpSocket."]
#[doc = " <para> See also: %PseudoTcpCallbacks:WritePacket </para>"]
#[doc = ""]
#[doc = " Since: 0.0.11"]
pub type PseudoTcpWriteResult = i32;
pub const PseudoTcpShutdown_PSEUDO_TCP_SHUTDOWN_RD: PseudoTcpShutdown = 0;
pub const PseudoTcpShutdown_PSEUDO_TCP_SHUTDOWN_WR: PseudoTcpShutdown = 1;
pub const PseudoTcpShutdown_PSEUDO_TCP_SHUTDOWN_RDWR: PseudoTcpShutdown = 2;
#[doc = " PseudoTcpShutdown:"]
#[doc = " @PSEUDO_TCP_SHUTDOWN_RD: Shut down the local reader only"]
#[doc = " @PSEUDO_TCP_SHUTDOWN_WR: Shut down the local writer only"]
#[doc = " @PSEUDO_TCP_SHUTDOWN_RDWR: Shut down both reading and writing"]
#[doc = ""]
#[doc = " Options for which parts of a connection to shut down when calling"]
#[doc = " pseudo_tcp_socket_shutdown(). These correspond to the values passed to POSIX"]
#[doc = " shutdown()."]
#[doc = ""]
#[doc = " Since: 0.1.8"]
pub type PseudoTcpShutdown = i32;
#[doc = " PseudoTcpCallbacks:"]
#[doc = " @user_data: A user defined pointer to be passed to the callbacks"]
#[doc = " @PseudoTcpOpened: The #PseudoTcpSocket is now connected"]
#[doc = " @PseudoTcpReadable: The socket is readable"]
#[doc = " @PseudoTcpWritable: The socket is writable"]
#[doc = " @PseudoTcpClosed: The socket was closed (both sides)"]
#[doc = " @WritePacket: This callback is called when the socket needs to send data."]
#[doc = ""]
#[doc = " A structure containing callbacks functions that will be called by the"]
#[doc = " #PseudoTcpSocket when some events happen."]
#[doc = " <para> See also: #PseudoTcpWriteResult </para>"]
#[doc = ""]
#[doc = " Since: 0.0.11"]
#[repr(C)]
pub struct PseudoTcpCallbacks {
    pub user_data: gpointer,
    pub PseudoTcpOpened:
    ::std::option::Option<unsafe extern "C" fn(tcp: *mut PseudoTcpSocket, data: gpointer)>,
    pub PseudoTcpReadable:
    ::std::option::Option<unsafe extern "C" fn(tcp: *mut PseudoTcpSocket, data: gpointer)>,
    pub PseudoTcpWritable:
    ::std::option::Option<unsafe extern "C" fn(tcp: *mut PseudoTcpSocket, data: gpointer)>,
    pub PseudoTcpClosed: ::std::option::Option<
        unsafe extern "C" fn(tcp: *mut PseudoTcpSocket, error: guint32, data: gpointer),
    >,
    pub WritePacket: ::std::option::Option<
        unsafe extern "C" fn(
            tcp: *mut PseudoTcpSocket,
            buffer: *const gchar,
            len: guint32,
            data: gpointer,
        ) -> PseudoTcpWriteResult,
    >,
}
#[test]
fn bindgen_test_layout_PseudoTcpCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<PseudoTcpCallbacks>(),
        48usize,
        concat!("Size of: ", stringify!(PseudoTcpCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<PseudoTcpCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(PseudoTcpCallbacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PseudoTcpCallbacks>())).user_data as *const _ as usize },
        0usize,
        concat!(
        "Offset of field: ",
        stringify!(PseudoTcpCallbacks),
        "::",
        stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PseudoTcpCallbacks>())).PseudoTcpOpened as *const _ as usize
        },
        8usize,
        concat!(
        "Offset of field: ",
        stringify!(PseudoTcpCallbacks),
        "::",
        stringify!(PseudoTcpOpened)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PseudoTcpCallbacks>())).PseudoTcpReadable as *const _ as usize
        },
        16usize,
        concat!(
        "Offset of field: ",
        stringify!(PseudoTcpCallbacks),
        "::",
        stringify!(PseudoTcpReadable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PseudoTcpCallbacks>())).PseudoTcpWritable as *const _ as usize
        },
        24usize,
        concat!(
        "Offset of field: ",
        stringify!(PseudoTcpCallbacks),
        "::",
        stringify!(PseudoTcpWritable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PseudoTcpCallbacks>())).PseudoTcpClosed as *const _ as usize
        },
        32usize,
        concat!(
        "Offset of field: ",
        stringify!(PseudoTcpCallbacks),
        "::",
        stringify!(PseudoTcpClosed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PseudoTcpCallbacks>())).WritePacket as *const _ as usize },
        40usize,
        concat!(
        "Offset of field: ",
        stringify!(PseudoTcpCallbacks),
        "::",
        stringify!(WritePacket)
        )
    );
}
extern "C" {
    #[doc = " pseudo_tcp_socket_new:"]
    #[doc = " @conversation: The conversation id for the socket."]
    #[doc = " @callbacks: A pointer to the #PseudoTcpCallbacks structure for getting"]
    #[doc = " notified of the #PseudoTcpSocket events."]
    #[doc = ""]
    #[doc = " Creates a new #PseudoTcpSocket for the specified conversation"]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "The @callbacks must be non-NULL, in order to get notified of packets the"]
    #[doc = "socket needs to send."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "If the @callbacks structure was dynamicly allocated, it can be freed"]
    #[doc = "after the call @pseudo_tcp_socket_new"]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Returns: The new #PseudoTcpSocket object, %NULL on error"]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    pub fn pseudo_tcp_socket_new(
        conversation: guint32,
        callbacks: *mut PseudoTcpCallbacks,
    ) -> *mut PseudoTcpSocket;
}
extern "C" {
    #[doc = " pseudo_tcp_socket_connect:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = ""]
    #[doc = " Connects the #PseudoTcpSocket to the peer with the same conversation id."]
    #[doc = " The connection will only be successful after the"]
    #[doc = " %PseudoTcpCallbacks:PseudoTcpOpened callback is called"]
    #[doc = ""]
    #[doc = " Returns: %TRUE on success, %FALSE on failure (not in %TCP_LISTEN state)"]
    #[doc = " <para> See also: pseudo_tcp_socket_get_error() </para>"]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    pub fn pseudo_tcp_socket_connect(self_: *mut PseudoTcpSocket) -> gboolean;
}
extern "C" {
    #[doc = " pseudo_tcp_socket_recv:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = " @buffer: The buffer to fill with received data"]
    #[doc = " @len: The length of @buffer"]
    #[doc = ""]
    #[doc = " Receive data from the socket."]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "Only call this on the %PseudoTcpCallbacks:PseudoTcpReadable callback."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "This function should be called in a loop. If this function does not"]
    #[doc = "return -1 with EWOULDBLOCK as the error, the"]
    #[doc = "%PseudoTcpCallbacks:PseudoTcpReadable callback will not be called again."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Returns: The number of bytes received or -1 in case of error"]
    #[doc = " <para> See also: pseudo_tcp_socket_get_error() </para>"]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    pub fn pseudo_tcp_socket_recv(
        self_: *mut PseudoTcpSocket,
        buffer: *mut ::std::os::raw::c_char,
        len: size_t,
    ) -> gint;
}
extern "C" {
    #[doc = " pseudo_tcp_socket_send:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = " @buffer: The buffer with data to send"]
    #[doc = " @len: The length of @buffer"]
    #[doc = ""]
    #[doc = " Send data on the socket."]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "If this function return -1 with EWOULDBLOCK as the error, or if the return"]
    #[doc = "value is lower than @len, then the %PseudoTcpCallbacks:PseudoTcpWritable"]
    #[doc = "callback will be called when the socket will become writable."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Returns: The number of bytes sent or -1 in case of error"]
    #[doc = " <para> See also: pseudo_tcp_socket_get_error() </para>"]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    pub fn pseudo_tcp_socket_send(
        self_: *mut PseudoTcpSocket,
        buffer: *const ::std::os::raw::c_char,
        len: guint32,
    ) -> gint;
}
extern "C" {
    #[doc = " pseudo_tcp_socket_close:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = " @force: %TRUE to close the socket forcefully, %FALSE to close it gracefully"]
    #[doc = ""]
    #[doc = " Close the socket for sending. If @force is set to %FALSE, the socket will"]
    #[doc = " finish sending pending data before closing. If it is set to %TRUE, the socket"]
    #[doc = " will discard pending data and close the connection immediately (sending a TCP"]
    #[doc = " RST segment)."]
    #[doc = ""]
    #[doc = " The socket will be closed in both directions  sending and receiving  and"]
    #[doc = " any pending received data must be read before calling this function, by"]
    #[doc = " calling pseudo_tcp_socket_recv() until it blocks. If any pending data is in"]
    #[doc = " the receive buffer when pseudo_tcp_socket_close() is called, a TCP RST"]
    #[doc = " segment will be sent to the peer to notify it of the data loss."]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "The %PseudoTcpCallbacks:PseudoTcpClosed callback will not be called once"]
    #[doc = "the socket gets closed. It is only used for aborted connection."]
    #[doc = "Instead, the socket gets closed when the pseudo_tcp_socket_get_next_clock()"]
    #[doc = "function returns FALSE."]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " <para> See also: pseudo_tcp_socket_get_next_clock() </para>"]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    pub fn pseudo_tcp_socket_close(self_: *mut PseudoTcpSocket, force: gboolean);
}
extern "C" {
    #[doc = " pseudo_tcp_socket_shutdown:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = " @how: The directions of the connection to shut down."]
    #[doc = ""]
    #[doc = " Shut down sending, receiving, or both on the socket, depending on the value"]
    #[doc = " of @how. The behaviour of pseudo_tcp_socket_send() and"]
    #[doc = " pseudo_tcp_socket_recv() will immediately change after this function returns"]
    #[doc = " (depending on the value of @how), though the socket may continue to process"]
    #[doc = " network traffic in the background even if sending or receiving data is"]
    #[doc = " forbidden."]
    #[doc = ""]
    #[doc = " This is equivalent to the POSIX shutdown() function. Setting @how to"]
    #[doc = " %PSEUDO_TCP_SHUTDOWN_RDWR is equivalent to calling pseudo_tcp_socket_close()."]
    #[doc = ""]
    #[doc = " Since: 0.1.8"]
    pub fn pseudo_tcp_socket_shutdown(self_: *mut PseudoTcpSocket, how: PseudoTcpShutdown);
}
extern "C" {
    #[doc = " pseudo_tcp_socket_get_error:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = ""]
    #[doc = " Return the last encountered error."]
    #[doc = ""]
    #[doc = "<note>"]
    #[doc = "<para>"]
    #[doc = "The return value can be :"]
    #[doc = "<para>"]
    #[doc = "EINVAL (for pseudo_tcp_socket_connect())."]
    #[doc = "</para>"]
    #[doc = "<para>"]
    #[doc = "EWOULDBLOCK or ENOTCONN (for pseudo_tcp_socket_recv() and"]
    #[doc = "pseudo_tcp_socket_send())."]
    #[doc = "</para>"]
    #[doc = "</para>"]
    #[doc = "</note>"]
    #[doc = ""]
    #[doc = " Returns: The error code"]
    #[doc = " <para> See also: pseudo_tcp_socket_connect() </para>"]
    #[doc = " <para> See also: pseudo_tcp_socket_recv() </para>"]
    #[doc = " <para> See also: pseudo_tcp_socket_send() </para>"]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    pub fn pseudo_tcp_socket_get_error(self_: *mut PseudoTcpSocket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " pseudo_tcp_socket_get_next_clock:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = " @timeout: A pointer to be filled with the new timeout."]
    #[doc = ""]
    #[doc = " Call this to determine the timeout needed before the next time call"]
    #[doc = " to pseudo_tcp_socket_notify_clock() should be made."]
    #[doc = ""]
    #[doc = " Returns: %TRUE if @timeout was filled, %FALSE if the socket is closed and"]
    #[doc = " ready to be destroyed."]
    #[doc = ""]
    #[doc = " <para> See also: pseudo_tcp_socket_notify_clock() </para>"]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    pub fn pseudo_tcp_socket_get_next_clock(
        self_: *mut PseudoTcpSocket,
        timeout: *mut guint64,
    ) -> gboolean;
}
extern "C" {
    #[doc = " pseudo_tcp_socket_notify_clock:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = ""]
    #[doc = " Start the processing of receiving data, pending data or syn/acks."]
    #[doc = " Call this based on timeout value returned by"]
    #[doc = " pseudo_tcp_socket_get_next_clock()."]
    #[doc = " It's ok to call this too frequently."]
    #[doc = ""]
    #[doc = " <para> See also: pseudo_tcp_socket_get_next_clock() </para>"]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    pub fn pseudo_tcp_socket_notify_clock(self_: *mut PseudoTcpSocket);
}
extern "C" {
    #[doc = " pseudo_tcp_socket_notify_mtu:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = " @mtu: The new MTU of the socket"]
    #[doc = ""]
    #[doc = " Set the MTU of the socket"]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    pub fn pseudo_tcp_socket_notify_mtu(self_: *mut PseudoTcpSocket, mtu: guint16);
}
extern "C" {
    #[doc = " pseudo_tcp_socket_notify_packet:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = " @buffer: The buffer containing the received data"]
    #[doc = " @len: The length of @buffer"]
    #[doc = ""]
    #[doc = " Notify the #PseudoTcpSocket when a new packet arrives"]
    #[doc = ""]
    #[doc = " Returns: %TRUE if the packet was processed successfully, %FALSE otherwise"]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    pub fn pseudo_tcp_socket_notify_packet(
        self_: *mut PseudoTcpSocket,
        buffer: *const gchar,
        len: guint32,
    ) -> gboolean;
}
extern "C" {
    #[doc = " pseudo_tcp_socket_notify_message:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = " @message: A #NiceInputMessage containing the received data."]
    #[doc = ""]
    #[doc = " Notify the #PseudoTcpSocket that a new message has arrived, and enqueue the"]
    #[doc = " data in its buffers to the #PseudoTcpSockets receive buffer."]
    #[doc = ""]
    #[doc = " Returns: %TRUE if the packet was processed successfully, %FALSE otherwise"]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn pseudo_tcp_socket_notify_message(
        self_: *mut PseudoTcpSocket,
        message: *mut NiceInputMessage,
    ) -> gboolean;
}
extern "C" {
    #[doc = " pseudo_tcp_set_debug_level:"]
    #[doc = " @level: The level of debug to set"]
    #[doc = ""]
    #[doc = " Sets the debug level to enable/disable normal/verbose debug messages."]
    #[doc = ""]
    #[doc = " Since: 0.0.11"]
    pub fn pseudo_tcp_set_debug_level(level: PseudoTcpDebugLevel);
}
extern "C" {
    #[doc = " pseudo_tcp_socket_get_available_bytes:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = ""]
    #[doc = " Gets the number of bytes of data in the buffer that can be read without"]
    #[doc = " receiving more packets from the network."]
    #[doc = ""]
    #[doc = " Returns: The number of bytes or -1 if the connection is not established"]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn pseudo_tcp_socket_get_available_bytes(self_: *mut PseudoTcpSocket) -> gint;
}
extern "C" {
    #[doc = " pseudo_tcp_socket_can_send:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = ""]
    #[doc = " Returns if there is space in the send buffer to send any data."]
    #[doc = ""]
    #[doc = " Returns: %TRUE if data can be sent, %FALSE otherwise"]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn pseudo_tcp_socket_can_send(self_: *mut PseudoTcpSocket) -> gboolean;
}
extern "C" {
    #[doc = " pseudo_tcp_socket_get_available_send_space:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = ""]
    #[doc = " Gets the number of bytes of space available in the transmission buffer."]
    #[doc = ""]
    #[doc = " Returns: The number of bytes, or 0 if the connection is not established."]
    #[doc = ""]
    #[doc = " Since: 0.1.5"]
    pub fn pseudo_tcp_socket_get_available_send_space(self_: *mut PseudoTcpSocket) -> gsize;
}
extern "C" {
    #[doc = " pseudo_tcp_socket_set_time:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = " @current_time: Current monotonic time, in milliseconds; or zero to use the"]
    #[doc = " system monotonic clock."]
    #[doc = ""]
    #[doc = " Sets the current monotonic time to be used by the TCP socket when calculating"]
    #[doc = " timeouts and expiry times. If this function is not called, or is called with"]
    #[doc = " @current_time as zero, g_get_monotonic_time() will be used. Otherwise, the"]
    #[doc = " specified @current_time will be used until it is updated by calling this"]
    #[doc = " function again."]
    #[doc = ""]
    #[doc = " This function is intended for testing only, and should not be used in"]
    #[doc = " production code."]
    #[doc = ""]
    #[doc = " Since: 0.1.8"]
    pub fn pseudo_tcp_socket_set_time(self_: *mut PseudoTcpSocket, current_time: guint32);
}
extern "C" {
    #[doc = " pseudo_tcp_socket_is_closed:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = ""]
    #[doc = " Gets whether the socket is closed, with the shutdown handshake completed,"]
    #[doc = " and both peers no longer able to read or write data to the connection."]
    #[doc = ""]
    #[doc = " Returns: %TRUE if the socket is closed in both directions, %FALSE otherwise"]
    #[doc = " Since: 0.1.8"]
    pub fn pseudo_tcp_socket_is_closed(self_: *mut PseudoTcpSocket) -> gboolean;
}
extern "C" {
    #[doc = " pseudo_tcp_socket_is_closed_remotely:"]
    #[doc = " @self: The #PseudoTcpSocket object."]
    #[doc = ""]
    #[doc = " Gets whether the socket has been closed on the remote peers side of the"]
    #[doc = " connection (i.e. whether pseudo_tcp_socket_close() has been called there)."]
    #[doc = " This is guaranteed to return %TRUE if pseudo_tcp_socket_is_closed() returns"]
    #[doc = " %TRUE. It will not return %TRUE after pseudo_tcp_socket_close() is called"]
    #[doc = " until a FIN segment is received from the remote peer."]
    #[doc = ""]
    #[doc = " Returns: %TRUE if the remote peer has closed its side of the connection,"]
    #[doc = " %FALSE otherwise"]
    #[doc = " Since: 0.1.8"]
    pub fn pseudo_tcp_socket_is_closed_remotely(self_: *mut PseudoTcpSocket) -> gboolean;
}
